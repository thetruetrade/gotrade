
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/thetruetrade/gotrade/indicators/adl.go</option>
				
				<option value="file1">github.com/thetruetrade/gotrade/indicators/adx.go</option>
				
				<option value="file2">github.com/thetruetrade/gotrade/indicators/adxr.go</option>
				
				<option value="file3">github.com/thetruetrade/gotrade/indicators/aroon.go</option>
				
				<option value="file4">github.com/thetruetrade/gotrade/indicators/aroonosc.go</option>
				
				<option value="file5">github.com/thetruetrade/gotrade/indicators/atr.go</option>
				
				<option value="file6">github.com/thetruetrade/gotrade/indicators/avgprice.go</option>
				
				<option value="file7">github.com/thetruetrade/gotrade/indicators/bollingerbands.go</option>
				
				<option value="file8">github.com/thetruetrade/gotrade/indicators/cci.go</option>
				
				<option value="file9">github.com/thetruetrade/gotrade/indicators/chainkinosc.go</option>
				
				<option value="file10">github.com/thetruetrade/gotrade/indicators/dema.go</option>
				
				<option value="file11">github.com/thetruetrade/gotrade/indicators/dx.go</option>
				
				<option value="file12">github.com/thetruetrade/gotrade/indicators/ema.go</option>
				
				<option value="file13">github.com/thetruetrade/gotrade/indicators/hhv.go</option>
				
				<option value="file14">github.com/thetruetrade/gotrade/indicators/hhvbars.go</option>
				
				<option value="file15">github.com/thetruetrade/gotrade/indicators/indicators.go</option>
				
				<option value="file16">github.com/thetruetrade/gotrade/indicators/kama.go</option>
				
				<option value="file17">github.com/thetruetrade/gotrade/indicators/linearreg.go</option>
				
				<option value="file18">github.com/thetruetrade/gotrade/indicators/linearregangle.go</option>
				
				<option value="file19">github.com/thetruetrade/gotrade/indicators/linearregintercept.go</option>
				
				<option value="file20">github.com/thetruetrade/gotrade/indicators/linearregslope.go</option>
				
				<option value="file21">github.com/thetruetrade/gotrade/indicators/llv.go</option>
				
				<option value="file22">github.com/thetruetrade/gotrade/indicators/llvbars.go</option>
				
				<option value="file23">github.com/thetruetrade/gotrade/indicators/macd.go</option>
				
				<option value="file24">github.com/thetruetrade/gotrade/indicators/medprice.go</option>
				
				<option value="file25">github.com/thetruetrade/gotrade/indicators/mfi.go</option>
				
				<option value="file26">github.com/thetruetrade/gotrade/indicators/minusdi.go</option>
				
				<option value="file27">github.com/thetruetrade/gotrade/indicators/minusdm.go</option>
				
				<option value="file28">github.com/thetruetrade/gotrade/indicators/momentum.go</option>
				
				<option value="file29">github.com/thetruetrade/gotrade/indicators/obv.go</option>
				
				<option value="file30">github.com/thetruetrade/gotrade/indicators/plusdi.go</option>
				
				<option value="file31">github.com/thetruetrade/gotrade/indicators/plusdm.go</option>
				
				<option value="file32">github.com/thetruetrade/gotrade/indicators/roc.go</option>
				
				<option value="file33">github.com/thetruetrade/gotrade/indicators/rocp.go</option>
				
				<option value="file34">github.com/thetruetrade/gotrade/indicators/rocr.go</option>
				
				<option value="file35">github.com/thetruetrade/gotrade/indicators/rocr100.go</option>
				
				<option value="file36">github.com/thetruetrade/gotrade/indicators/rsi.go</option>
				
				<option value="file37">github.com/thetruetrade/gotrade/indicators/sar.go</option>
				
				<option value="file38">github.com/thetruetrade/gotrade/indicators/sma.go</option>
				
				<option value="file39">github.com/thetruetrade/gotrade/indicators/stddeviation.go</option>
				
				<option value="file40">github.com/thetruetrade/gotrade/indicators/stochasticosc.go</option>
				
				<option value="file41">github.com/thetruetrade/gotrade/indicators/tema.go</option>
				
				<option value="file42">github.com/thetruetrade/gotrade/indicators/trima.go</option>
				
				<option value="file43">github.com/thetruetrade/gotrade/indicators/truerange.go</option>
				
				<option value="file44">github.com/thetruetrade/gotrade/indicators/tsf.go</option>
				
				<option value="file45">github.com/thetruetrade/gotrade/indicators/typicalprice.go</option>
				
				<option value="file46">github.com/thetruetrade/gotrade/indicators/variance.go</option>
				
				<option value="file47">github.com/thetruetrade/gotrade/indicators/williamsr.go</option>
				
				<option value="file48">github.com/thetruetrade/gotrade/indicators/wma.go</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >package indicators

import (
        "github.com/thetruetrade/gotrade"
)

// An Accumulation Distribution Line Indicator (Adl), no storage, for use in other indicators
type AdlWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        previousAdl          float64
}

// NewAdlWithoutStorage creates an Accumulation Distribution Line Indicator (Adl) without storage
func NewAdlWithoutStorage(valueAvailableAction ValueAvailableActionFloat) (indicator *AdlWithoutStorage, err error) <span class="cov5" title="67">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov1" title="1">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        <span class="cov5" title="66">ind := AdlWithoutStorage{
                baseIndicator:        newBaseIndicator(0),
                baseFloatBounds:      newBaseFloatBounds(),
                previousAdl:          float64(0.0),
                valueAvailableAction: valueAvailableAction,
        }

        return &amp;ind, nil</span>
}

// An Accumulation Distribution Line Indicator (Adl)
type Adl struct {
        *AdlWithoutStorage

        // public variables
        Data []float64
}

// NewAdl creates an Accumulation Distribution Line Indicator (Adl) for online usage
func NewAdl() (indicator *Adl, err error) <span class="cov5" title="44">{
        ind := Adl{}
        ind.AdlWithoutStorage, err = NewAdlWithoutStorage(func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="2572">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov5" title="44">return &amp;ind, err</span>
}

// NewAdlWithSrcLen creates an Accumulation Distribution Line Indicator (Adl) for offline usage
func NewAdlWithSrcLen(sourceLength int) (indicator *Adl, err error) <span class="cov4" title="23">{
        ind, err := NewAdl()
        ind.Data = make([]float64, 0, sourceLength)

        return ind, err
}</span>

// NewAdlForStream creates an Accumulation Distribution Line Indicator (Adl) for online usage with a source data stream
func NewAdlForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Adl, err error) <span class="cov3" title="10">{
        ind, err := NewAdl()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewAdlForStreamWithSrcLen creates an Accumulation Distribution Line Indicator (Adl) for offline usage with a source data stream
func NewAdlForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Adl, err error) <span class="cov3" title="12">{
        ind, err := NewAdlWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *AdlWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="3955">{
        // increment the number of results this indicator can be expected to return
        ind.dataLength += 1

        moneyFlowMultiplier := ((tickData.C() - tickData.L()) - (tickData.H() - tickData.C())) / (tickData.H() - tickData.L())
        moneyFlowVolume := moneyFlowMultiplier * tickData.V()
        result := ind.previousAdl + moneyFlowVolume

        if ind.validFromBar == -1 </span><span class="cov4" title="37">{
                // set the streamBarIndex from which this indicator returns valid results
                ind.validFromBar = streamBarIndex
        }</span>

        // update the maximum result value
        <span class="cov10" title="3955">if result &gt; ind.maxValue </span><span class="cov6" title="188">{
                ind.maxValue = result
        }</span>

        // update the minimum result value
        <span class="cov10" title="3955">if result &lt; ind.minValue </span><span class="cov4" title="24">{
                ind.minValue = result
        }</span>

        // notify of a new result value though the value available action
        <span class="cov10" title="3955">ind.valueAvailableAction(result, streamBarIndex)

        ind.previousAdl = result</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// An Average Directional Index (Adx), no storage, for use in other indicators
type AdxWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        dx                   *DxWithoutStorage
        currentDX            float64
        sumDX                float64
        previousAdx          float64
        timePeriod           int
}

// NewAdxWithoutStorage creates an Average Directional Index (Adx) without storage
func NewAdxWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *AdxWithoutStorage, err error) <span class="cov6" title="197">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov1" title="1">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for an Adx indicator is 2
        <span class="cov6" title="196">if timePeriod &lt; 2 </span><span class="cov1" title="1">{
                return nil, errors.New("timePeriod " + ErrStrBelowMinimum + " (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov6" title="195">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov1" title="1">{
                return nil, errors.New("timePeriod " + ErrStrAboveMaximum + " (100000)")
        }</span>

        <span class="cov6" title="194">lookback := (2 * timePeriod) - 1
        ind := AdxWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        timePeriod * -1,
                currentDX:            0.0,
                sumDX:                0.0,
                previousAdx:          0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.dx, err = NewDxWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="9326">{

                ind.currentDX = dataItem

                ind.periodCounter += 1
                if ind.periodCounter &lt; 0 </span><span class="cov7" title="694">{
                        ind.sumDX += ind.currentDX
                }</span> <span class="cov9" title="8632">else if ind.periodCounter == 0 </span><span class="cov5" title="94">{
                        // increment the number of results this indicator can be expected to return
                        ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov5" title="94">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        <span class="cov5" title="94">ind.sumDX += ind.currentDX
                        result := ind.sumDX / float64(ind.timePeriod)

                        // update the maximum result value
                        if result &gt; ind.maxValue </span><span class="cov5" title="94">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov5" title="94">if result &lt; ind.minValue </span><span class="cov5" title="94">{
                                ind.minValue = result
                        }</span>
                        <span class="cov5" title="94">ind.valueAvailableAction(result, streamBarIndex)
                        ind.previousAdx = result</span>

                } <span class="cov9" title="8538">else {

                        ind.dataLength += 1

                        result := (ind.previousAdx*float64(ind.timePeriod-1) + ind.currentDX) / float64(ind.timePeriod)

                        // update the maximum result value
                        if result &gt; ind.maxValue </span><span class="cov4" title="56">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov9" title="8538">if result &lt; ind.minValue </span><span class="cov8" title="3048">{
                                ind.minValue = result
                        }</span>
                        // notify of a new result value though the value available action
                        <span class="cov9" title="8538">ind.valueAvailableAction(result, streamBarIndex)

                        ind.previousAdx = result</span>
                }

        })

        <span class="cov6" title="194">return &amp;ind, err</span>
}

// A Directional Movement Indicator (Adx)
type Adx struct {
        *AdxWithoutStorage

        // public variables
        Data []float64
}

// NewAdx creates an Average Directional Index (Adx) for online usage
func NewAdx(timePeriod int) (indicator *Adx, err error) <span class="cov5" title="97">{

        ind := Adx{}
        ind.AdxWithoutStorage, err = NewAdxWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="4304">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov5" title="97">return &amp;ind, err</span>
}

// NewDefaultAdx creates an Average Directional Index (Adx) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultAdx() (indicator *Adx, err error) <span class="cov4" title="42">{
        timePeriod := 14
        return NewAdx(timePeriod)
}</span>

// NewAdxWithSrcLen creates an Average Directional Index (Adx) for offline usage
func NewAdxWithSrcLen(sourceLength int, timePeriod int) (indicator *Adx, err error) <span class="cov4" title="23">{
        ind, err := NewAdx(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultAdxWithSrcLen creates an Average Directional Index (Adx) for offline usage with default parameters
func NewDefaultAdxWithSrcLen(sourceLength int) (indicator *Adx, err error) <span class="cov4" title="23">{

        ind, err := NewDefaultAdx()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewAdxForStream creates an Average Directional Index (Adx) for online usage with a source data stream
func NewAdxForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Adx, err error) <span class="cov3" title="10">{
        ind, err := NewAdx(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAdxForStream creates an Average Directional Index (Adx) for online usage with a source data stream
func NewDefaultAdxForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Adx, err error) <span class="cov3" title="10">{
        ind, err := NewDefaultAdx()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewAdxForStreamWithSrcLen creates an Average Directional Index (Adx) for offline usage with a source data stream
func NewAdxForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Adx, err error) <span class="cov3" title="12">{
        ind, err := NewAdxWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAdxForStreamWithSrcLen creates an Average Directional Index (Adx) for offline usage with a source data stream
func NewDefaultAdxForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Adx, err error) <span class="cov3" title="12">{
        ind, err := NewDefaultAdxWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *AdxWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="10118">{
        ind.dx.ReceiveDOHLCVTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// An Average Directional Index Rating (Adxr), no storage
type AdxrWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodCounter        int
        periodHistory        *list.List
        adx                  *AdxWithoutStorage
        valueAvailableAction ValueAvailableActionFloat
        timePeriod           int
}

// NewAdxrWithoutStorage creates an Average Directional Index Rating (Adxr) without storage
func NewAdxrWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *AdxrWithoutStorage, err error) <span class="cov5" title="100">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov1" title="1">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for an Adxr indicator is 2
        <span class="cov5" title="99">if timePeriod &lt; 2 </span><span class="cov1" title="1">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov5" title="98">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov1" title="1">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov5" title="97">ind := AdxrWithoutStorage{
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        0,
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.adx, err = NewAdxWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="4328">{
                ind.periodHistory.PushBack(dataItem)

                if ind.periodCounter &gt; ind.GetLookbackPeriod() </span><span class="cov9" title="3981">{
                        adxN := ind.periodHistory.Front().Value.(float64)
                        result := (dataItem + adxN) / 2.0

                        ind.dataLength += 1
                        if ind.validFromBar == -1 </span><span class="cov5" title="45">{
                                ind.validFromBar = streamBarIndex
                        }</span>

                        <span class="cov9" title="3981">if result &gt; ind.maxValue </span><span class="cov5" title="77">{
                                ind.maxValue = result
                        }</span>

                        <span class="cov9" title="3981">if result &lt; ind.minValue </span><span class="cov8" title="1366">{
                                ind.minValue = result
                        }</span>

                        <span class="cov9" title="3981">ind.valueAvailableAction(result, streamBarIndex)</span>
                }

                <span class="cov9" title="4328">if ind.periodHistory.Len() &gt;= timePeriod </span><span class="cov9" title="3981">{
                        first := ind.periodHistory.Front()
                        ind.periodHistory.Remove(first)
                }</span>
        })

        <span class="cov5" title="97">var lookback int = 3
        if timePeriod &gt; 1 </span><span class="cov5" title="97">{
                lookback = timePeriod - 1 + ind.adx.GetLookbackPeriod()
        }</span>
        <span class="cov5" title="97">ind.baseIndicator = newBaseIndicator(lookback)

        return &amp;ind, nil</span>
}

// A Directional Movement Indicator Rating (Adxr)
type Adxr struct {
        *AdxrWithoutStorage

        // public variables
        Data []float64
}

// NewAdxr creates an Average Directional Index Rating (Adxr) for online usage
func NewAdxr(timePeriod int) (indicator *Adxr, err error) <span class="cov5" title="97">{
        ind := Adxr{}
        ind.AdxrWithoutStorage, err = NewAdxrWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="3981">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov5" title="97">return &amp;ind, err</span>
}

// NewDefaultAdxr creates an Average Directional Index Rating (Adxr) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultAdxr() (indicator *Adxr, err error) <span class="cov4" title="42">{
        timePeriod := 14
        return NewAdxr(timePeriod)
}</span>

// NewAdxrWithSrcLen creates an Average Directional Index Rating (Adxr) for offline usage
func NewAdxrWithSrcLen(sourceLength int, timePeriod int) (indicator *Adxr, err error) <span class="cov4" title="23">{
        ind, err := NewAdxr(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultAdxrWithSrcLen creates an Average Directional Index Rating (Adxr) for offline usage with default parameters
func NewDefaultAdxrWithSrcLen(sourceLength int) (indicator *Adxr, err error) <span class="cov4" title="23">{

        ind, err := NewDefaultAdxr()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewAdxrForStream creates an Average Directional Rating Index (Adxr) for online usage with a source data stream
func NewAdxrForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Adxr, err error) <span class="cov3" title="10">{
        ind, err := NewAdxr(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAdxrForStream creates an Average Directional Index Rating (Adxr) for online usage with a source data stream
func NewDefaultAdxrForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Adxr, err error) <span class="cov3" title="10">{
        ind, err := NewDefaultAdxr()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewAdxrForStreamWithSrcLen creates an Average Directional Index Rating (Adxr) for offline usage with a source data stream
func NewAdxrForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Adxr, err error) <span class="cov3" title="12">{
        ind, err := NewAdxrWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAdxrForStreamWithSrcLen creates an Average Directional Index Rating (Adxr) for offline usage with a source data stream
func NewDefaultAdxrForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Adxr, err error) <span class="cov3" title="12">{
        ind, err := NewDefaultAdxrWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *AdxrWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="5071">{
        ind.periodCounter += 1
        ind.adx.ReceiveDOHLCVTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// An Aroon (Aroon), no storage, for use in other indicators
type AroonWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodCounter        int
        periodHighHistory    *list.List
        periodLowHistory     *list.List
        valueAvailableAction ValueAvailableActionAroon
        aroonFactor          float64
        timePeriod           int
}

// NewAroonWithoutStorage creates an Aroon (Aroon) without storage
func NewAroonWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionAroon) (indicator *AroonWithoutStorage, err error) <span class="cov4" title="45">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for an Aroon indicator is 2
        <span class="cov4" title="45">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="45">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="45">lookback := timePeriod
        ind := AroonWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod + 1) * -1,
                periodHighHistory:    list.New(),
                periodLowHistory:     list.New(),
                valueAvailableAction: valueAvailableAction,
                aroonFactor:          100.0 / float64(timePeriod),
        }

        return &amp;ind, nil</span>
}

// An Aroon (Aroon)
type Aroon struct {
        *AroonWithoutStorage

        // public variables
        Up   []float64
        Down []float64
}

// NewAroon creates an Aroon (Aroon) for online usage
func NewAroon(timePeriod int) (indicator *Aroon, err error) <span class="cov3" title="23">{
        ind := Aroon{}
        ind.AroonWithoutStorage, err = NewAroonWithoutStorage(timePeriod,
                func(dataItemAroonUp float64, dataItemAroonDown float64, streamBarIndex int) </span><span class="cov7" title="1452">{
                        ind.Up = append(ind.Up, dataItemAroonUp)
                        ind.Down = append(ind.Down, dataItemAroonDown)
                }</span>)
        <span class="cov3" title="23">return &amp;ind, err</span>
}

// NewDefaultAroon creates an Aroon (Aroon) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultAroon() (indicator *Aroon, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewAroon(timePeriod)
}</span>

// NewAroonWithSrcLen creates an Aroon (Aroon) for offline usage
func NewAroonWithSrcLen(sourceLength int, timePeriod int) (indicator *Aroon, err error) <span class="cov0" title="0">{
        ind, err := NewAroon(timePeriod)
        ind.Up = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.Down = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultAroonWithSrcLen creates an Aroon (Aroon) for offline usage with default parameters
func NewDefaultAroonWithSrcLen(sourceLength int) (indicator *Aroon, err error) <span class="cov0" title="0">{

        ind, err := NewDefaultAroon()
        ind.Up = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.Down = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewAroonForStream creates an Aroon (Aroon) for online usage with a source data stream
func NewAroonForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Aroon, err error) <span class="cov0" title="0">{
        ind, err := NewAroon(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAroonForStream creates an Aroon (Aroon) for online usage with a source data stream
func NewDefaultAroonForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Aroon, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultAroon()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewAroonForStreamWithSrcLen creates an Aroon (Aroon) for online usage with a source data stream
func NewAroonForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Aroon, err error) <span class="cov0" title="0">{
        ind, err := NewAroonWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAroonForStreamWithSrcLen creates an Aroon (Aroon) for online usage with a source data stream
func NewDefaultAroonForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Aroon, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultAroonWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *AroonWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov7" title="2953">{
        ind.periodCounter += 1
        ind.periodHighHistory.PushBack(tickData.H())
        ind.periodLowHistory.PushBack(tickData.L())

        if ind.periodHighHistory.Len() &gt; (1 + ind.GetLookbackPeriod()) </span><span class="cov7" title="2651">{
                var first = ind.periodHighHistory.Front()
                ind.periodHighHistory.Remove(first)
                first = ind.periodLowHistory.Front()
                ind.periodLowHistory.Remove(first)
        }</span>

        <span class="cov7" title="2953">if ind.periodCounter &gt;= 0 </span><span class="cov7" title="2678">{
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov3" title="27">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                <span class="cov7" title="2678">var aroonUp float64
                var aroonDwn float64

                var highValue float64 = math.SmallestNonzeroFloat64
                var highIdx int = -1
                var i int = (1 + ind.GetLookbackPeriod())
                for e := ind.periodHighHistory.Front(); e != nil; e = e.Next() </span><span class="cov10" title="38668">{
                        i--
                        var value float64 = e.Value.(float64)
                        if highValue &lt;= value </span><span class="cov9" title="17421">{
                                highValue = value
                                highIdx = i
                        }</span>
                }
                <span class="cov7" title="2678">var daysSinceHigh = highIdx

                var lowValue float64 = math.MaxFloat64
                var lowIdx int = -1
                i = (1 + ind.GetLookbackPeriod())
                for e := ind.periodLowHistory.Front(); e != nil; e = e.Next() </span><span class="cov10" title="38668">{
                        i--
                        var value float64 = e.Value.(float64)
                        if lowValue &gt;= value </span><span class="cov8" title="11223">{
                                lowValue = value
                                lowIdx = i
                        }</span>

                }
                <span class="cov7" title="2678">var daysSinceLow = lowIdx

                aroonUp = ind.aroonFactor * float64(ind.GetLookbackPeriod()-daysSinceHigh)
                aroonDwn = ind.aroonFactor * float64(ind.GetLookbackPeriod()-daysSinceLow)

                // update the maximum result value
                if aroonUp &gt; ind.maxValue </span><span class="cov3" title="32">{
                        ind.maxValue = aroonUp
                }</span>

                // update the minimum result value
                <span class="cov7" title="2678">if aroonDwn &lt; ind.minValue </span><span class="cov3" title="27">{
                        ind.minValue = aroonDwn
                }</span>

                // notify of a new result value though the value available action
                <span class="cov7" title="2678">ind.valueAvailableAction(aroonUp, aroonDwn, streamBarIndex)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

type AroonOscWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        //private variables
        valueAvailableAction ValueAvailableActionFloat
        aroon                *AroonWithoutStorage
}

func NewAroonOscWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *AroonOscWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for an AroonOsc indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := AroonOscWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                valueAvailableAction: valueAvailableAction,
        }

        ind.aroon, err = NewAroonWithoutStorage(timePeriod,
                func(dataItemAroonUp float64, dataItemAroonDown float64, streamBarIndex int) </span><span class="cov9" title="1226">{
                        // increment the number of results this indicator can be expected to return
                        ind.dataLength++

                        result := dataItemAroonUp - dataItemAroonDown
                        if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        // update the maximum result value
                        <span class="cov9" title="1226">if result &gt; ind.maxValue </span><span class="cov4" title="15">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov9" title="1226">if result &lt; ind.minValue </span><span class="cov5" title="45">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov9" title="1226">ind.valueAvailableAction(result, streamBarIndex)</span>
                })
        <span class="cov4" title="22">return &amp;ind, nil</span>
}

// An AroonOsc (AroonOsc)
type AroonOsc struct {
        *AroonOscWithoutStorage

        // public variables
        Data []float64
}

// NewAroonOsc creates an Aroon Oscillator (AroonOsc) for online usage
func NewAroonOsc(timePeriod int) (indicator *AroonOsc, err error) <span class="cov4" title="22">{

        ind := AroonOsc{}
        ind.AroonOscWithoutStorage, err = NewAroonOscWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1226">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultAroonOsc creates an Aroon Oscillator (AroonOsc) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultAroonOsc() (indicator *AroonOsc, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewAroonOsc(timePeriod)
}</span>

// NewAroonOscWithSrcLen creates an Aroon Oscillator (AroonOsc) for offline usage
func NewAroonOscWithSrcLen(sourceLength int, timePeriod int) (indicator *AroonOsc, err error) <span class="cov0" title="0">{
        ind, err := NewAroonOsc(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultAroonOscWithSrcLen creates an Aroon Oscillator (AroonOsc) for offline usage with default parameters
func NewDefaultAroonOscWithSrcLen(sourceLength int) (indicator *AroonOsc, err error) <span class="cov0" title="0">{

        ind, err := NewDefaultAroonOsc()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewAroonOscForStream creates an Aroon Oscillator (AroonOsc) for online usage with a source data stream
func NewAroonOscForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *AroonOsc, err error) <span class="cov0" title="0">{
        ind, err := NewAroonOsc(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAroonOscForStream creates an Aroon Oscillator (AroonOsc) for online usage with a source data stream
func NewDefaultAroonOscForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *AroonOsc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultAroonOsc()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewAroonOscForStreamWithSrcLen creates an Aroon Oscillator (AroonOsc) for offline usage with a source data stream
func NewAroonOscForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *AroonOsc, err error) <span class="cov0" title="0">{
        ind, err := NewAroonOscWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAroonOscForStreamWithSrcLen creates an Aroon Oscillator (AroonOsc) for offline usage with a source data stream
func NewDefaultAroonOscForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *AroonOsc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultAroonOscWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *AroonOsc) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1351">{
        ind.aroon.ReceiveDOHLCVTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// An Average True Range Indicator (Atr), no storage, for use in other indicators
type AtrWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        trueRange            *TrueRangeWithoutStorage
        sma                  *SmaWithoutStorage
        previousAvgTrueRange float64
        multiplier           float64
        timePeriod           int
}

// NewAtrWithoutStorage creates an Average True Range Indicator (Atr) without storage
func NewAtrWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *AtrWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for an Atr indicator is 1
        <span class="cov4" title="22">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := AtrWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                multiplier:           float64(timePeriod - 1),
                previousAvgTrueRange: -1,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.sma, err = NewSmaWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov4" title="13">{
                ind.previousAvgTrueRange = dataItem

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov4" title="13">if dataItem &gt; ind.maxValue </span><span class="cov4" title="13">{
                        ind.maxValue = dataItem
                }</span>

                // update the minimum result value
                <span class="cov4" title="13">if dataItem &lt; ind.minValue </span><span class="cov4" title="13">{
                        ind.minValue = dataItem
                }</span>

                // notify of a new result value though the value available action
                <span class="cov4" title="13">ind.valueAvailableAction(dataItem, streamBarIndex)</span>
        })

        <span class="cov4" title="22">ind.trueRange, err = NewTrueRangeWithoutStorage(func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1406">{

                if ind.previousAvgTrueRange == -1 </span><span class="cov7" title="234">{
                        ind.sma.ReceiveTick(dataItem, streamBarIndex)
                }</span> <span class="cov9" title="1172">else {

                        // increment the number of results this indicator can be expected to return
                        ind.dataLength += 1

                        result := ((ind.previousAvgTrueRange * ind.multiplier) + dataItem) / float64(ind.timePeriod)

                        // update the maximum result value
                        if result &gt; ind.maxValue </span><span class="cov6" title="94">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov9" title="1172">if result &lt; ind.minValue </span><span class="cov4" title="12">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov9" title="1172">ind.valueAvailableAction(result, streamBarIndex)

                        // update the previous true range for the next tick
                        ind.previousAvgTrueRange = result</span>
                }

        })
        <span class="cov4" title="22">return &amp;ind, nil</span>
}

// An Average True Range Indicator (Atr)
type Atr struct {
        *AtrWithoutStorage

        // public variables
        Data []float64
}

// NewAtr creates an Average True Range (Atr) for online usage
func NewAtr(timePeriod int) (indicator *Atr, err error) <span class="cov4" title="22">{
        ind := Atr{}
        ind.AtrWithoutStorage, err = NewAtrWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1185">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultAtr creates an Average True Range (Atr) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultAtr() (indicator *Atr, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewAtr(timePeriod)
}</span>

// NewAtrWithSrcLen creates an Average True Range (Atr) for offline usage
func NewAtrWithSrcLen(sourceLength int, timePeriod int) (indicator *Atr, err error) <span class="cov0" title="0">{
        ind, err := NewAtr(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultAtrWithSrcLen creates an Average True Range (Atr) for offline usage with default parameters
func NewDefaultAtrWithSrcLen(sourceLength int) (indicator *Atr, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultAtr()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewAtrForStream creates an Average True Range (Atr) for online usage with a source data stream
func NewAtrForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Atr, err error) <span class="cov0" title="0">{
        ind, err := NewAtr(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAtrForStream creates an Average True Range (Atr) for online usage with a source data stream
func NewDefaultAtrForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Atr, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultAtr()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewAtrForStreamWithSrcLen creates an Average True Range (Atr) for offline usage with a source data stream
func NewAtrForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Atr, err error) <span class="cov0" title="0">{
        ind, err := NewAtrWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultAtrForStreamWithSrcLen creates an Average True Range (Atr) for offline usage with a source data stream
func NewDefaultAtrForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Atr, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultAtrWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *AtrWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1423">{
        // update the current true range
        ind.trueRange.ReceiveDOHLCVTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package indicators

import (
        "github.com/thetruetrade/gotrade"
)

// An Average Price (AvgPrice), no storage, for use in other indicators
type AvgPriceWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
}

// NewAvgPriceWithoutStorage creates an Average Price(AvgPrice) without storage
func NewAvgPriceWithoutStorage(valueAvailableAction ValueAvailableActionFloat) (indicator *AvgPriceWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        <span class="cov4" title="22">lookback := 0
        ind := AvgPriceWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                valueAvailableAction: valueAvailableAction,
        }

        return &amp;ind, nil</span>
}

// An Average Price Indicator
type AvgPrice struct {
        *AvgPriceWithoutStorage

        // public variables
        Data []float64
}

// NewAvgPrice creates an Average Price (AvgPrice) for online usage
func NewAvgPrice() (indicator *AvgPrice, err error) <span class="cov4" title="22">{
        ind := AvgPrice{}
        ind.AvgPriceWithoutStorage, err = NewAvgPriceWithoutStorage(func(dataItem float64, streamBarIndex int) </span><span class="cov10" title="1311">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewAvgPriceWithSrcLen creates an Avgerage Price Indicator(AvgPrice) for offline usage
func NewAvgPriceWithSrcLen(sourceLength int) (indicator *AvgPrice, err error) <span class="cov0" title="0">{
        ind, err := NewAvgPrice()
        ind.Data = make([]float64, 0, sourceLength)

        return ind, err
}</span>

// NewAvgPriceForStream creates an Avgerage Price Indicator(AvgPrice) for online usage with a source data stream
func NewAvgPriceForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *AvgPrice, err error) <span class="cov0" title="0">{
        ind, err := NewAvgPrice()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewAvgPriceForStreamWithSrcLen creates an Avgerage Price Indicator(AvgPrice) for offline usage with a source data stream
func NewAvgPriceForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *AvgPrice, err error) <span class="cov0" title="0">{
        ind, err := NewAvgPriceWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *AvgPriceWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1311">{

        // increment the number of results this indicator can be expected to return
        ind.dataLength += 1

        if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                // set the streamBarIndex from which this indicator returns valid results
                ind.validFromBar = streamBarIndex
        }</span>

        <span class="cov10" title="1311">result := (tickData.O() + tickData.H() + tickData.L() + tickData.C()) / float64(4.0)

        // update the maximum result value
        if result &gt; ind.maxValue </span><span class="cov8" title="307">{
                ind.maxValue = result
        }</span>

        // update the minimum result value
        <span class="cov10" title="1311">if result &lt; ind.minValue </span><span class="cov5" title="31">{
                ind.minValue = result
        }</span>

        // notify of a new result value though the value available action
        <span class="cov10" title="1311">ind.valueAvailableAction(result, streamBarIndex)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Bollinger Band Indicator (BollingerBand), no storage, for use in other indicators
type BollingerBandsWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionBollinger
        sma                  *SmaWithoutStorage
        stdDev               *StdDevWithoutStorage
        currentSma           float64
        timePeriod           int
}

// NewBollingerBandsWithoutStorage creates a Bollinger Band Indicator (BollingerBand) without storage
func NewBollingerBandsWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionBollinger) (indicator *BollingerBandsWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for a Bollinger Band indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod - 1
        ind := BollingerBandsWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                currentSma:           0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.sma, err = NewSmaWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1279">{
                ind.currentSma = dataItem
        }</span>)

        <span class="cov4" title="22">ind.stdDev, err = NewStdDevWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1279">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        ind.validFromBar = streamBarIndex
                }</span>

                <span class="cov9" title="1279">var upperBand = ind.currentSma + 2*dataItem
                var lowerBand = ind.currentSma - 2*dataItem

                // update the maximum result value
                if upperBand &gt; ind.maxValue </span><span class="cov7" title="216">{
                        ind.maxValue = upperBand
                }</span>

                // update the minimum result value
                <span class="cov9" title="1279">if lowerBand &lt; ind.minValue </span><span class="cov6" title="61">{
                        ind.minValue = lowerBand
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1279">ind.valueAvailableAction(upperBand, ind.currentSma, lowerBand, streamBarIndex)</span>
        })

        <span class="cov4" title="22">return &amp;ind, nil</span>
}

// A Bollinger Band Indicator
type BollingerBands struct {
        *BollingerBandsWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        UpperBand  []float64
        MiddleBand []float64
        LowerBand  []float64
}

// NewBollingerBands creates a Bollinger Band Indicator (BollingerBand) for online usage
func NewBollingerBands(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *BollingerBands, err error) <span class="cov4" title="22">{
        ind := BollingerBands{selectData: selectData}

        ind.BollingerBandsWithoutStorage, err = NewBollingerBandsWithoutStorage(
                timePeriod,
                func(dataItemUpperBand float64, dataItemMiddleBand float64, dataItemLowerBand float64, streamBarIndex int) </span><span class="cov9" title="1279">{
                        ind.UpperBand = append(ind.UpperBand, dataItemUpperBand)
                        ind.MiddleBand = append(ind.MiddleBand, dataItemMiddleBand)
                        ind.LowerBand = append(ind.LowerBand, dataItemLowerBand)
                }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultBollingerBands creates a Bollinger Band Indicator (BollingerBand) for online usage with default parameters
//        - timePeriod: 5
//  - selectData: useClosePrice
func NewDefaultBollingerBands() (indicator *BollingerBands, err error) <span class="cov0" title="0">{
        timePeriod := 5
        return NewBollingerBands(timePeriod, gotrade.UseClosePrice)
}</span>

// NewBollingerBandsWithSrcLen creates a Bollinger Band Indicator (BollingerBand) for offline usage
func NewBollingerBandsWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *BollingerBands, err error) <span class="cov0" title="0">{
        ind, err := NewBollingerBands(timePeriod, selectData)
        ind.UpperBand = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.MiddleBand = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.LowerBand = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultBollingerBandsWithSrcLen creates a Bollinger Band Indicator (BollingerBand) for offline usage
func NewDefaultBollingerBandsWithSrcLen(sourceLength int) (indicator *BollingerBands, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultBollingerBands()
        ind.UpperBand = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.MiddleBand = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.LowerBand = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewBollingerBandsForStream creates a Bollinger Bands Indicator (BollingerBand) for online usage with a source data stream
func NewBollingerBandsForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *BollingerBands, err error) <span class="cov0" title="0">{
        ind, err := NewBollingerBands(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultBollingerBandsForStream creates a Bollinger Bands Indicator (BollingerBand) for online usage with a source data stream
func NewDefaultBollingerBandsForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *BollingerBands, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultBollingerBands()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewBollingerBandsForStreamWithSrcLen creates a Bollinger Bands Indicator (BollingerBand) for online usage with a source data stream
func NewBollingerBandsForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *BollingerBands, err error) <span class="cov0" title="0">{
        ind, err := NewBollingerBandsWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultBollingerBandsForStreamWithSrcLen creates a Bollinger Bands Indicator (BollingerBand) for online usage with a source data stream
func NewDefaultBollingerBandsForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *BollingerBands, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultBollingerBandsWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *BollingerBands) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1327">{
        var selectedData float64 = ind.selectData(tickData)
        ind.RecieveTick(selectedData, streamBarIndex)
}</span>

// ReceiveTick consumes a source data float price tick
func (ind *BollingerBandsWithoutStorage) RecieveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1327">{
        ind.sma.ReceiveTick(tickData, streamBarIndex)
        ind.stdDev.ReceiveTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Commodity Channel Index Indicator (Cci), no storage, for use in other indicators
type CciWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction   ValueAvailableActionFloat
        periodCounter          int
        typicalPriceAvg        *SmaWithoutStorage
        factor                 float64
        typicalPriceHistory    *list.List
        currentAvgTypicalPrice float64
        currentTypicalPrice    float64
        timePeriod             int
}

// NewCciWithoutStorage creates a Commodity Channel Index Indicator (Cci) without storage
func NewCciWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *CciWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for a CCi indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod - 1
        ind := CciWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                factor:               0.015,
                periodCounter:        (timePeriod * -1),
                valueAvailableAction: valueAvailableAction,
                typicalPriceHistory:  list.New(),
                timePeriod:           timePeriod,
        }

        ind.typicalPriceAvg, err = NewSmaWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov8" title="1271">{
                currentTypicalPriceAvg := dataItem

                var meanDeviation float64 = 0.0
                // calculate the mean deviation
                for e := ind.typicalPriceHistory.Front(); e != nil; e = e.Next() </span><span class="cov10" title="9049">{
                        value := e.Value.(float64)
                        meanDeviation += math.Abs(value - currentTypicalPriceAvg)
                }</span>
                <span class="cov8" title="1271">meanDeviation /= float64(ind.timePeriod)

                result := ((ind.currentTypicalPrice - currentTypicalPriceAvg) / (ind.factor * meanDeviation))

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov3" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov8" title="1271">if result &gt; ind.maxValue </span><span class="cov4" title="31">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov8" title="1271">if result &lt; ind.minValue </span><span class="cov4" title="33">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov8" title="1271">ind.valueAvailableAction(result, streamBarIndex)</span>
        })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// A Commodity Channel Index Indicator (Cci)
type Cci struct {
        *CciWithoutStorage

        // public variables
        Data []float64
}

// NewCci creates a Commodity Channel Index Indicator (Cci) for online usage
func NewCci(timePeriod int) (indicator *Cci, err error) <span class="cov4" title="22">{
        ind := Cci{}
        ind.CciWithoutStorage, err = NewCciWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov8" title="1271">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultCci creates a Commodity Channel Index (Cci) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultCci() (indicator *Cci, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewCci(timePeriod)
}</span>

// NewCciWithSrcLen creates a Commodity Channel Index (Cci) for offline usage
func NewCciWithSrcLen(sourceLength int, timePeriod int) (indicator *Cci, err error) <span class="cov0" title="0">{
        ind, err := NewCci(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultCciWithSrcLen creates a Commodity Channel Index (Cci) for offline usage with default parameters
func NewDefaultCciWithSrcLen(sourceLength int) (indicator *Cci, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultCci()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewCciForStream creates a Commodity Channel Index (Cci) for online usage with a source data stream
func NewCciForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Cci, err error) <span class="cov0" title="0">{
        ind, err := NewCci(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultCciForStream creates a Commodity Channel Index (Cci) for online usage with a source data stream
func NewDefaultCciForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Cci, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultCci()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewCciForStreamWithSrcLen creates a Commodity Channel Index (Cci) for offline usage with a source data stream
func NewCciForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Cci, err error) <span class="cov0" title="0">{
        ind, err := NewCciWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultCciForStreamWithSrcLen creates a Commodity Channel Index (Cci) for offline usage with a source data stream
func NewDefaultCciForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Cci, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultCciWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Cci) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov8" title="1327">{
        ind.periodCounter += 1

        // calculate the typical price
        typicalPrice := (tickData.H() + tickData.L() + tickData.C()) / 3.0
        ind.currentTypicalPrice = typicalPrice

        // push it to the history
        ind.typicalPriceHistory.PushBack(typicalPrice)

        // trim the history
        if ind.typicalPriceHistory.Len() &gt; ind.timePeriod </span><span class="cov8" title="1258">{
                var first = ind.typicalPriceHistory.Front()
                ind.typicalPriceHistory.Remove(first)
        }</span>

        // add it to the average
        <span class="cov8" title="1327">ind.typicalPriceAvg.ReceiveTick(typicalPrice, streamBarIndex)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Chaikin Oscillator Indicator (ChaikinOsc), no storage, for use in other indicators
type ChaikinOscWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        fastTimePeriod       int
        slowTimePeriod       int
        valueAvailableAction ValueAvailableActionFloat
        adl                  *AdlWithoutStorage
        emaFast              float64
        emaSlow              float64
        emaFastMultiplier    float64
        emaSlowMultiplier    float64
        periodCounter        int
        isInitialised        bool
}

// NewChaikinOscWithoutStorage creates a Chaikin Oscillator Indicator (ChaikinOsc) without storage
// This should be as simple as EMA(Adl,3) - EMA(Adl,10), however it seems the TA-Lib emas are intialised with the
// first adl value and not offset like the macd to conincide, they are both calculated from the 2nd bar and used before their
// lookback period is reached - so the emas are calculated inline and not using the general EmaWithoutStorage
func NewChaikinOscWithoutStorage(fastTimePeriod int, slowTimePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *ChaikinOscWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum fastTimePeriod for a Chaikin Oscillator Indicator is 2
        <span class="cov4" title="22">if fastTimePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("fastTimePeriod is less than the minimum (2)")
        }</span>

        // the minimum slowTimePeriod for a Chaikin Oscillator Indicator is 2
        <span class="cov4" title="22">if slowTimePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("slowTimePeriod is less than the minimum (2)")
        }</span>

        // check the maximum fastTimePeriod
        <span class="cov4" title="22">if fastTimePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("fastTimePeriod is greater than the maximum (100000)")
        }</span>

        // check the maximum slowTimePeriod
        <span class="cov4" title="22">if slowTimePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("slowTimePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := slowTimePeriod - 1
        ind := ChaikinOscWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                slowTimePeriod:       slowTimePeriod,
                fastTimePeriod:       fastTimePeriod,
                emaFastMultiplier:    float64(2.0 / float64(fastTimePeriod+1.0)),
                emaSlowMultiplier:    float64(2.0 / float64(slowTimePeriod+1.0)),
                periodCounter:        slowTimePeriod * -1,
                isInitialised:        false,
                valueAvailableAction: valueAvailableAction,
        }

        ind.adl, err = NewAdlWithoutStorage(func(dataItem float64, streamBarIndex int) </span><span class="cov10" title="1383">{
                ind.periodCounter += 1

                if !ind.isInitialised </span><span class="cov4" title="17">{
                        ind.emaFast = dataItem
                        ind.emaSlow = dataItem
                        ind.isInitialised = true
                }</span>
                <span class="cov10" title="1383">if ind.periodCounter &lt; 0 </span><span class="cov7" title="153">{
                        ind.emaFast = (dataItem-ind.emaFast)*ind.emaFastMultiplier + ind.emaFast
                        ind.emaSlow = (dataItem-ind.emaSlow)*ind.emaSlowMultiplier + ind.emaSlow
                }</span>

                <span class="cov10" title="1383">if ind.periodCounter &gt;= 0 </span><span class="cov9" title="1230">{
                        // increment the number of results this indicator can be expected to return
                        ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        <span class="cov9" title="1230">ind.emaFast = (dataItem-ind.emaFast)*ind.emaFastMultiplier + ind.emaFast
                        ind.emaSlow = (dataItem-ind.emaSlow)*ind.emaSlowMultiplier + ind.emaSlow
                        chaikinOsc := ind.emaFast - ind.emaSlow

                        // update the maximum result value
                        if chaikinOsc &gt; ind.maxValue </span><span class="cov4" title="18">{
                                ind.maxValue = chaikinOsc
                        }</span>

                        // update the minimum result value
                        <span class="cov9" title="1230">if chaikinOsc &lt; ind.minValue </span><span class="cov4" title="22">{
                                ind.minValue = chaikinOsc
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov9" title="1230">ind.valueAvailableAction(chaikinOsc, streamBarIndex)</span>
                }
        })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// A Chaikin Oscillator Indicator (ChaikinOsc)
type ChaikinOsc struct {
        *ChaikinOscWithoutStorage

        // public variables
        Data []float64
}

// NewChaikinOsc creates a Chaikin Oscillator (ChaikinOsc) for online usage
func NewChaikinOsc(fastTimePeriod int, slowTimePeriod int) (indicator *ChaikinOsc, err error) <span class="cov4" title="22">{

        newChaikinOsc := ChaikinOsc{}
        newChaikinOsc.ChaikinOscWithoutStorage, err = NewChaikinOscWithoutStorage(fastTimePeriod, slowTimePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1230">{
                        newChaikinOsc.Data = append(newChaikinOsc.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">return &amp;newChaikinOsc, err</span>
}

// NewDefaultChaikinOsc creates a Chaikin Oscillator (ChaikinOsc) for online usage with default parameters
//        - fastTimePeriod: 3
//  - slowTimePeriod: 10
func NewDefaultChaikinOsc() (indicator *ChaikinOsc, err error) <span class="cov0" title="0">{
        fastTimePeriod := 3
        slowTimePeriod := 10
        return NewChaikinOsc(fastTimePeriod, slowTimePeriod)
}</span>

// NewChaikinOscWithSrcLen creates a Chaikin Oscillator (ChaikinOsc) for offline usage
func NewChaikinOscWithSrcLen(sourceLength int, fastTimePeriod int, slowTimePeriod int) (indicator *ChaikinOsc, err error) <span class="cov0" title="0">{
        ind, err := NewChaikinOsc(fastTimePeriod, slowTimePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultChaikinOscWithSrcLen creates a Chaikin Oscillator (ChaikinOsc) for offline usage with default parameters
func NewDefaultChaikinOscWithSrcLen(sourceLength int) (indicator *ChaikinOsc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultChaikinOsc()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewChaikinOscForStream creates a Chaikin Oscillator (ChaikinOsc) for online usage with a source data stream
func NewChaikinOscForStream(priceStream gotrade.DOHLCVStreamSubscriber, fastTimePeriod int, slowTimePeriod int) (indicator *ChaikinOsc, err error) <span class="cov0" title="0">{
        newChaikinOsc, err := NewChaikinOsc(fastTimePeriod, slowTimePeriod)
        priceStream.AddTickSubscription(newChaikinOsc)
        return newChaikinOsc, err
}</span>

// NewChaikinOscForStreamWithSrcLen creates a Chaikin Oscillator (ChaikinOsc) for offline usage with a source data stream
func NewChaikinOscForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, fastTimePeriod int, slowTimePeriod int) (indicator *ChaikinOsc, err error) <span class="cov0" title="0">{
        ind, err := NewChaikinOscWithSrcLen(sourceLength, fastTimePeriod, slowTimePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultChaikinOscForStreamWithSrcLen creates a Chaikin Oscillator (ChaikinOsc) for offline usage with a source data stream
func NewDefaultChaikinOscForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *ChaikinOsc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultChaikinOscWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *ChaikinOsc) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1383">{
        ind.adl.ReceiveDOHLCVTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package indicators

// Dema(X) = (2 * EMA(X, CLOSE)) - (EMA(X, EMA(X, CLOSE)))

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Double Exponential Moving Average Indicator (Dema), no storage, for use in other indicators
type DemaWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        ema1                 *EmaWithoutStorage
        ema2                 *EmaWithoutStorage
        currentEMA           float64
}

// NewDemaWithoutStorage creates a Double Exponential Moving Average Indicator (Dema) without storage
func NewDemaWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *DemaWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for a Dema indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := 2 * (timePeriod - 1)
        ind := DemaWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                valueAvailableAction: valueAvailableAction,
        }

        ind.ema1, _ = NewEmaWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1295">{
                ind.currentEMA = dataItem
                ind.ema2.ReceiveTick(dataItem, streamBarIndex)
        }</span>)

        <span class="cov4" title="22">ind.ema2, _ = NewEmaWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1247">{
                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // Dema(X) = (2 * EMA(X, CLOSE)) - (EMA(X, EMA(X, CLOSE)))
                <span class="cov9" title="1247">dema := (2 * ind.currentEMA) - dataItem

                // update the maximum result value
                if dema &gt; ind.maxValue </span><span class="cov7" title="201">{
                        ind.maxValue = dema
                }</span>

                // update the minimum result value
                <span class="cov9" title="1247">if dema &lt; ind.minValue </span><span class="cov5" title="43">{
                        ind.minValue = dema
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1247">ind.valueAvailableAction(dema, streamBarIndex)</span>
        })

        <span class="cov4" title="22">return &amp;ind, nil</span>
}

// A Double Exponential Moving Average Indicator (Dema)
type Dema struct {
        *DemaWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewDema creates a Double Exponential Moving Average (Dema) for online usage
func NewDema(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Dema, err error) <span class="cov4" title="22">{

        ind := Dema{selectData: selectData}
        ind.DemaWithoutStorage, err = NewDemaWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1247">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultDema creates a Double Exponential Moving Average (Dema) for online usage with default parameters
//        - timePeriod: 30
//  - selectData: useClosePrice
func NewDefaultDema() (indicator *Dema, err error) <span class="cov0" title="0">{
        timePeriod := 30
        selectData := gotrade.UseClosePrice
        return NewDema(timePeriod, selectData)
}</span>

// NewDemaWithSrcLen creates a Double Exponential Moving Average (Dema) for offline usage
func NewDemaWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Dema, err error) <span class="cov0" title="0">{
        ind, err := NewDema(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultDemaWithSrcLen creates a Double Exponential Moving Average (Dema) for offline usage with default parameters
func NewDefaultDemaWithSrcLen(sourceLength int) (indicator *Dema, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultDema()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewDemaForStream creates a Double Exponential Moving Average (Dema) for online usage with a source data stream
func NewDemaForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Dema, err error) <span class="cov0" title="0">{
        newDema, err := NewDema(timePeriod, selectData)
        priceStream.AddTickSubscription(newDema)
        return newDema, err
}</span>

// NewDefaultDemaForStream creates a Double Exponential Moving Average (Dema) for online usage with a source data stream
func NewDefaultDemaForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Dema, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultDema()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDemaForStreamWithSrcLen creates a Double Exponential Moving Average (Dema) for offline usage with a source data stream
func NewDemaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Dema, err error) <span class="cov0" title="0">{
        ind, err := NewDemaWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultDemaForStreamWithSrcLen creates a Double Exponential Moving Average (Dema) for offline usage with a source data stream
func NewDefaultDemaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Dema, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultDemaWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (dema *Dema) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1343">{
        var selectedData = dema.selectData(tickData)
        dema.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (dema *DemaWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1343">{
        dema.ema1.ReceiveTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package indicators

// DX = ( (+DI)-(-DI) ) / ( (+DI) + (-DI) )

import (
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// An Directional Movement Index Indicator (Dx), no storage, for use in other indicators
type DxWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        minusDI              *MinusDi
        plusDI               *PlusDi
        currentPlusDi        float64
        currentMinusDi       float64
        timePeriod           int
}

// NewDxWithoutStorage creates a Directional Movement Index Indicator (Dx) without storage
func NewDxWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *DxWithoutStorage, err error) <span class="cov6" title="216">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov6" title="216">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov6" title="216">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov6" title="216">lookback := 2
        if timePeriod &gt; 1 </span><span class="cov6" title="216">{
                lookback = timePeriod
        }</span>

        <span class="cov6" title="216">ind := DxWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                currentPlusDi:        0.0,
                currentMinusDi:       0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.minusDI, err = NewMinusDi(timePeriod)

        ind.minusDI.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="10511">{
                ind.currentMinusDi = dataItem
        }</span>

        <span class="cov6" title="216">ind.plusDI, err = NewPlusDi(timePeriod)

        ind.plusDI.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="10511">{
                ind.currentPlusDi = dataItem

                var result float64
                tmp := ind.currentMinusDi + ind.currentPlusDi
                if tmp != 0.0 </span><span class="cov9" title="10511">{
                        result = 100.0 * (math.Abs(ind.currentMinusDi-ind.currentPlusDi) / tmp)
                }</span> <span class="cov0" title="0">else {
                        result = 0.0
                }</span>

                // increment the number of results this indicator can be expected to return
                <span class="cov9" title="10511">ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov5" title="111">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov9" title="10511">if result &gt; ind.maxValue </span><span class="cov6" title="189">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="10511">if result &lt; ind.minValue </span><span class="cov7" title="618">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="10511">ind.valueAvailableAction(result, streamBarIndex)</span>

        }

        <span class="cov6" title="216">return &amp;ind, err</span>
}

// A Directional Movement Index Indicator (Dx)
type Dx struct {
        *DxWithoutStorage

        // public variables
        Data []float64
}

// NewDx creates a Directional Movement Index Indicator (Dx) for online usage
func NewDx(timePeriod int) (indicator *Dx, err error) <span class="cov3" title="22">{

        ind := Dx{}
        ind.DxWithoutStorage, err = NewDxWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov7" title="1185">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov3" title="22">return &amp;ind, err</span>
}

// NewDefaultDx creates a Directional Movement Index (Dx) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultDx() (indicator *Dx, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewDx(timePeriod)
}</span>

// NewDxWithSrcLen creates a Directional Movement Index (Dx) for offline usage
func NewDxWithSrcLen(sourceLength int, timePeriod int) (indicator *Dx, err error) <span class="cov0" title="0">{
        ind, err := NewDx(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultDxWithSrcLen creates a Directional Movement Index (Dx) for offline usage with default parameters
func NewDefaultDxWithSrcLen(sourceLength int) (indicator *Dx, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultDx()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewDxForStream creates a Directional Movement Index (Dx) for online usage with a source data stream
func NewDxForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Dx, err error) <span class="cov0" title="0">{
        ind, err := NewDx(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultDxForStream creates a Directional Movement Index (Dx) for online usage with a source data stream
func NewDefaultDxForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Dx, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultDx()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDxForStreamWithSrcLen creates a Directional Movement Index (Dx) for offline usage with a source data stream
func NewDxForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Dx, err error) <span class="cov0" title="0">{
        ind, err := NewDxWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultDxForStreamWithSrcLen creates a Directional Movement Index (Dx) for offline usage with a source data stream
func NewDefaultDxForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Dx, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultDxWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *DxWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="11541">{
        ind.minusDI.ReceiveDOHLCVTick(tickData, streamBarIndex)
        ind.plusDI.ReceiveDOHLCVTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// An Exponential Moving Average Indicator (Ema), no storage, for use in other indicators
type EmaWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodTotal          float64
        periodCounter        int
        multiplier           float64
        previousEma          float64
        valueAvailableAction ValueAvailableActionFloat
        timePeriod           int
}

// NewEmaWithoutStorage creates an Exponential Moving Average Indicator (Ema) without storage
func NewEmaWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *EmaWithoutStorage, err error) <span class="cov6" title="198">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov6" title="198">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov6" title="198">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov6" title="198">lookback := timePeriod - 1
        ind := EmaWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        timePeriod * -1,
                multiplier:           float64(2.0 / float64(timePeriod+1.0)),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, err</span>
}

// An Exponential Moving Average Indicator (Ema)
type Ema struct {
        *EmaWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewEma creates an Exponential Moving Average Indicator (Ema) for online usage
func NewEma(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Ema, err error) <span class="cov3" title="22">{
        newEma := Ema{selectData: selectData}
        newEma.EmaWithoutStorage, err = NewEmaWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov7" title="1279">{
                        newEma.Data = append(newEma.Data, dataItem)
                }</span>)

        <span class="cov3" title="22">return &amp;newEma, err</span>
}

// NewDefaultEma creates an Exponential Moving Average (Ema) for online usage with default parameters
//        - timePeriod: 25
func NewDefaultEma() (indicator *Ema, err error) <span class="cov0" title="0">{
        timePeriod := 25
        return NewEma(timePeriod, gotrade.UseClosePrice)
}</span>

// NewEmaWithSrcLen creates an Exponential Moving Average (Ema) for offline usage
func NewEmaWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Ema, err error) <span class="cov0" title="0">{
        ind, err := NewEma(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultEmaWithSrcLen creates an Exponential Moving Average (Ema) for offline usage with default parameters
func NewDefaultEmaWithSrcLen(sourceLength int) (indicator *Ema, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultEma()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewEmaForStream creates an Exponential Moving Average (Ema) for online usage with a source data stream
func NewEmaForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Ema, err error) <span class="cov0" title="0">{
        ind, err := NewEma(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultEmaForStream creates an Exponential Moving Average (Ema) for online usage with a source data stream
func NewDefaultEmaForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Ema, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultEma()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewEmaForStreamWithSrcLen creates an Exponential Moving Average (Ema) for offline usage with a source data stream
func NewEmaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Ema, err error) <span class="cov0" title="0">{
        ind, err := NewEmaWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultEmaForStreamWithSrcLen creates an Exponential Moving Average (Ema) for offline usage with a source data stream
func NewDefaultEmaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Ema, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultEmaWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ema *Ema) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov7" title="1327">{
        var selectedData = ema.selectData(tickData)
        ema.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ema *EmaWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="11777">{
        ema.periodCounter += 1
        if ema.periodCounter &lt; 0 </span><span class="cov6" title="496">{
                ema.periodTotal += tickData
        }</span> <span class="cov9" title="11281">else if ema.periodCounter == 0 </span><span class="cov5" title="137">{

                // increment the number of results this indicator can be expected to return
                ema.dataLength += 1

                if ema.validFromBar == -1 </span><span class="cov5" title="137">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ema.validFromBar = streamBarIndex
                }</span>

                <span class="cov5" title="137">ema.periodTotal += tickData
                result := ema.periodTotal / float64(ema.timePeriod)
                ema.previousEma = result

                // update the maximum result value
                if result &gt; ema.maxValue </span><span class="cov5" title="137">{
                        ema.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov5" title="137">if result &lt; ema.minValue </span><span class="cov5" title="137">{
                        ema.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov5" title="137">ema.valueAvailableAction(ema.previousEma, streamBarIndex)</span>

        } <span class="cov9" title="11144">else if ema.periodCounter &gt; 0 </span><span class="cov9" title="11144">{
                // increment the number of results this indicator can be expected to return
                ema.dataLength += 1

                result := (tickData-ema.previousEma)*ema.multiplier + ema.previousEma
                ema.previousEma = result

                // update the maximum result value
                if result &gt; ema.maxValue </span><span class="cov8" title="2692">{
                        ema.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="11144">if result &lt; ema.minValue </span><span class="cov6" title="499">{
                        ema.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="11144">ema.valueAvailableAction(ema.previousEma, streamBarIndex)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Highest High Value Indicator (Hhv), no storage, for use in other indicators
type HhvWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodHistory        *list.List
        valueAvailableAction ValueAvailableActionFloat
        currentHigh          float64
        currentHighIndex     int
        timePeriod           int
}

// NewHhvWithoutStorage creates a Highest High Value Indicator Indicator (Hhv) without storage
func NewHhvWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *HhvWithoutStorage, err error) <span class="cov4" title="45">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov4" title="45">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="45">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="45">lookback := timePeriod - 1
        ind := HhvWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                currentHigh:          math.SmallestNonzeroFloat64,
                currentHighIndex:     0,
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Highest High Value Indicator (hhv)
type Hhv struct {
        *HhvWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewHhv creates a Highest High Value Indicator (Hhv) for online usage
func NewHhv(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Hhv, err error) <span class="cov4" title="22">{
        ind := Hhv{selectData: selectData}
        ind.HhvWithoutStorage, err = NewHhvWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov8" title="1271">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultHhv creates a Highest High Value Indicator (Hhv) for online usage with default parameters
//        - timePeriod: 25
func NewDefaultHhv() (indicator *Hhv, err error) <span class="cov0" title="0">{
        timePeriod := 25
        return NewHhv(timePeriod, gotrade.UseClosePrice)
}</span>

// NewHhvWithSrcLen creates a Highest High Value Indicator (Hhv)for offline usage
func NewHhvWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Hhv, err error) <span class="cov0" title="0">{
        ind, err := NewHhv(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultHhvWithSrcLen creates a Highest High Value Indicator (Hhv)for offline usage with default parameters
func NewDefaultHhvWithSrcLen(sourceLength int) (indicator *Hhv, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultHhv()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewHhvForStream creates a Highest High Value Indicator (Hhv)for online usage with a source data stream
func NewHhvForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Hhv, err error) <span class="cov0" title="0">{
        ind, err := NewHhv(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultHhvForStream creates a Highest High Value Indicator (Hhv)for online usage with a source data stream
func NewDefaultHhvForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Hhv, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultHhv()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewHhvForStreamWithSrcLen creates a Highest High Value Indicator (Hhv)for offline usage with a source data stream
func NewHhvForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Hhv, err error) <span class="cov0" title="0">{
        ind, err := NewHhvWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultHhvForStreamWithSrcLen creates a Highest High Value Indicator (Hhv)for offline usage with a source data stream
func NewDefaultHhvForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Hhv, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultHhvWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Hhv) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov8" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *HhvWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov9" title="2953">{
        ind.periodHistory.PushBack(tickData)

        // resize the history
        if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="2794">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)

                // make sure we haven't just removed the current high
                if ind.currentHighIndex == ind.timePeriod-1 </span><span class="cov8" title="1179">{
                        ind.currentHigh = math.SmallestNonzeroFloat64
                        // we have we need to find the new high in the history
                        var i int = ind.timePeriod - 1
                        for e := ind.periodHistory.Front(); e != nil; e = e.Next() </span><span class="cov10" title="5433">{
                                value := e.Value.(float64)
                                if value &gt; ind.currentHigh </span><span class="cov8" title="1501">{
                                        ind.currentHigh = value
                                        ind.currentHighIndex = i
                                }</span>
                                <span class="cov10" title="5433">i -= 1</span>
                        }
                } <span class="cov8" title="1615">else {
                        if tickData &gt; ind.currentHigh </span><span class="cov7" title="750">{
                                ind.currentHigh = tickData
                                ind.currentHighIndex = 0
                        }</span> <span class="cov8" title="865">else {
                                ind.currentHighIndex += 1
                        }</span>
                }
                <span class="cov9" title="2794">var result = ind.currentHigh

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov0" title="0">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov9" title="2794">if result &gt; ind.maxValue </span><span class="cov7" title="381">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="2794">if result &lt; ind.minValue </span><span class="cov4" title="38">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="2794">ind.valueAvailableAction(result, streamBarIndex)</span>
        } <span class="cov6" title="159">else {
                if tickData &gt; ind.currentHigh </span><span class="cov6" title="121">{
                        ind.currentHigh = tickData
                        ind.currentHighIndex = 0
                }</span> <span class="cov4" title="38">else {
                        ind.currentHighIndex += 1
                }</span>

                <span class="cov6" title="159">if ind.periodHistory.Len() == ind.timePeriod </span><span class="cov4" title="31">{
                        var result = ind.currentHigh

                        // increment the number of results this indicator can be expected to return
                        ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov4" title="31">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        // update the maximum result value
                        <span class="cov4" title="31">if result &gt; ind.maxValue </span><span class="cov4" title="31">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov4" title="31">if result &lt; ind.minValue </span><span class="cov4" title="31">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov4" title="31">ind.valueAvailableAction(result, streamBarIndex)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Highest High Value Bars Indicator (HhvBars), no storage, for use in other indicators
type HhvBarsWithoutStorage struct {
        *baseIndicator
        *baseIntBounds

        // private variables
        periodHistory        *list.List
        valueAvailableAction ValueAvailableActionInt
        currentHigh          float64
        currentHighIndex     int64
        timePeriod           int
}

// NewHhvBarsWithoutStorage creates a Highest High Value Bars Indicator Indicator (HhvBars) without storage
func NewHhvBarsWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionInt) (indicator *HhvBarsWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov4" title="22">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod - 1

        ind := HhvBarsWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseIntBounds:        newBaseIntBounds(),
                currentHigh:          math.SmallestNonzeroFloat64,
                currentHighIndex:     0,
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Highest High Value Bars Indicator (HhvBars)
type HhvBars struct {
        *HhvBarsWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []int64
}

// NewHhvBars creates a Highest High Value Bars Indicator (HhvBars) for online usage
func NewHhvBars(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *HhvBars, err error) <span class="cov4" title="22">{
        ind := HhvBars{selectData: selectData}
        ind.HhvBarsWithoutStorage, err = NewHhvBarsWithoutStorage(timePeriod, func(dataItem int64, streamBarIndex int) </span><span class="cov9" title="1271">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultHhvBars creates a Highest High Value Indicator (HhvBars) for online usage with default parameters
//        - timePeriod: 25
func NewDefaultHhvBars() (indicator *HhvBars, err error) <span class="cov0" title="0">{
        timePeriod := 25
        return NewHhvBars(timePeriod, gotrade.UseClosePrice)
}</span>

// NewHhvBarsWithSrcLen creates a Highest High Value Indicator (HhvBars)for offline usage
func NewHhvBarsWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *HhvBars, err error) <span class="cov0" title="0">{
        ind, err := NewHhvBars(timePeriod, selectData)
        ind.Data = make([]int64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultHhvBarsWithSrcLen creates a Highest High Value Indicator (HhvBars)for offline usage with default parameters
func NewDefaultHhvBarsWithSrcLen(sourceLength int) (indicator *HhvBars, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultHhvBars()
        ind.Data = make([]int64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewHhvBarsForStream creates a Highest High Value Indicator (HhvBars)for online usage with a source data stream
func NewHhvBarsForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *HhvBars, err error) <span class="cov0" title="0">{
        ind, err := NewHhvBars(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultHhvBarsForStream creates a Highest High Value Indicator (HhvBars)for online usage with a source data stream
func NewDefaultHhvBarsForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *HhvBars, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultHhvBars()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewHhvBarsForStreamWithSrcLen creates a Highest High Value Indicator (HhvBars)for offline usage with a source data stream
func NewHhvBarsForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *HhvBars, err error) <span class="cov0" title="0">{
        ind, err := NewHhvBarsWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultHhvBarsForStreamWithSrcLen creates a Highest High Value Indicator (HhvBars)for offline usage with a source data stream
func NewDefaultHhvBarsForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *HhvBars, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultHhvBarsWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *HhvBars) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov9" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *HhvBarsWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov9" title="1327">{
        ind.periodHistory.PushBack(tickData)

        // resize the history
        if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="1258">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)

                // make sure we haven't just removed the current high
                if ind.currentHighIndex == int64(ind.timePeriod-1) </span><span class="cov8" title="539">{
                        ind.currentHigh = math.SmallestNonzeroFloat64
                        // we have we need to find the new high in the history
                        var i int = ind.timePeriod - 1
                        for e := ind.periodHistory.Front(); e != nil; e = e.Next() </span><span class="cov10" title="2233">{
                                value := e.Value.(float64)
                                if value &gt; ind.currentHigh </span><span class="cov8" title="647">{
                                        ind.currentHigh = value
                                        ind.currentHighIndex = int64(i)
                                }</span>
                                <span class="cov10" title="2233">i -= 1</span>
                        }
                } <span class="cov8" title="719">else {
                        if tickData &gt; ind.currentHigh </span><span class="cov7" title="327">{
                                ind.currentHigh = tickData
                                ind.currentHighIndex = 0
                        }</span> <span class="cov7" title="392">else {
                                ind.currentHighIndex += 1
                        }</span>
                }

                <span class="cov9" title="1258">var result = ind.currentHighIndex

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov0" title="0">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov9" title="1258">if result &gt; ind.maxValue </span><span class="cov4" title="26">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="1258">if result &lt; ind.minValue </span><span class="cov1" title="2">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1258">ind.valueAvailableAction(result, streamBarIndex)</span>

        } <span class="cov5" title="69">else {
                if tickData &gt; ind.currentHigh </span><span class="cov5" title="49">{
                        ind.currentHigh = tickData
                        ind.currentHighIndex = 0
                }</span> <span class="cov4" title="20">else {
                        ind.currentHighIndex += 1
                }</span>

                <span class="cov5" title="69">if ind.periodHistory.Len() == ind.timePeriod </span><span class="cov3" title="13">{
                        var result = ind.currentHighIndex

                        // increment the number of results this indicator can be expected to return
                        ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov3" title="13">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        // update the maximum result value
                        <span class="cov3" title="13">if result &gt; ind.maxValue </span><span class="cov3" title="13">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov3" title="13">if result &lt; ind.minValue </span><span class="cov3" title="13">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov3" title="13">ind.valueAvailableAction(result, streamBarIndex)</span>
                }
        }

}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
        import "github.com/thetruetrade/gotrade"

        Package indicators provides a range of technical trading indicators.
        All indicators follow the basic structure of:
                - receiving price data,        processing this price data and storing the transformed result.
                - maximum and minimum bounds of the transformed results are calculated automatically.
                - a lookback period indicating the lag between source data and the transformed result.
                - the source data bar from which the indicator is valid

         Functions are provided for each indicator that provide indicator creation
         for the following scenarios:

         Online Usage
                - the data stream length is not known ahead of time, e.g. real time data streams
         Offline Usage
                - the data stream length is known ahead of time, e.g. historical data streams

        Both scenarios provide the following indicator creation functions
                 * Indicator with default parameters
                 * Indicator with default parameters for attachment to a data stream
                 * Indicator with specified parameters
                 * Indicator with specified parameters for attachment to a data stream
                 * Indicator without storage with specified parameters
                        - for use inside other indicators, has no storage of results which is instead
                        - provided via a callback when it becomes available for use in the parent indicator.
*/
package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

var (
        ErrSourceDataEmpty                      = errors.New("Source data is empty")
        ErrNotEnoughSourceDataForLookbackPeriod = errors.New("Source data does not contain enough data for the specfied lookback period")
        ErrLookbackPeriodMustBeGreaterThanZero  = errors.New("Lookback period must be greater than 0")
        ErrValueAvailableActionIsNil            = errors.New("ValueAvailableAction cannot be empty")
        ErrStrBelowMinimum                      = "is less than the minimum"
        ErrStrAboveMaximum                      = "is greater than the maximum"

        // lookback minimum
        MinimumLookbackPeriod int = 0
        // lookback maximum
        MaximumLookbackPeriod int = 100000
)

type Indicator interface {
        // the source data bar number from which this indicator is valid, starts at bar 1.
        ValidFromBar() int
        // the lookback period, if applicable, the amount of lag the indicator displays with regards to the source data.
        GetLookbackPeriod() int
        // the length of the transformed data generated by the indicator.
        Length() int
}

type IndicatorWithTimePeriod interface {
        GetTimePeriod() int
}

type IndicatorWithFloatBounds interface {
        // the minimum bound of the transformed data generated by the indicator.
        MinValue() float64
        // the maximum bound of the transformed data generated by the indicator.
        MaxValue() float64
}

type IndicatorWithIntBounds interface {
        // the minimum bound of the transformed data generated by the indicator.
        MinValue() int64
        // the maximum bound of the transformed data generated by the indicator.
        MaxValue() int64
}

type baseFloatBounds struct {
        minValue float64
        maxValue float64
}

func newBaseFloatBounds() *baseFloatBounds <span class="cov8" title="2951">{
        ind := baseFloatBounds{minValue: math.MaxFloat64, maxValue: math.SmallestNonzeroFloat64}
        return &amp;ind
}</span>

func (ind *baseFloatBounds) MinValue() float64 <span class="cov6" title="261">{
        return ind.minValue
}</span>

func (ind *baseFloatBounds) MaxValue() float64 <span class="cov6" title="261">{
        return ind.maxValue
}</span>

type baseIntBounds struct {
        minValue int64
        maxValue int64
}

func newBaseIntBounds() *baseIntBounds <span class="cov4" title="44">{
        ind := baseIntBounds{minValue: math.MaxInt64, maxValue: math.MinInt64}
        return &amp;ind
}</span>

func (ind *baseIntBounds) MinValue() int64 <span class="cov3" title="10">{
        return ind.minValue
}</span>

func (ind *baseIntBounds) MaxValue() int64 <span class="cov3" title="10">{
        return ind.maxValue
}</span>

type baseIndicator struct {
        validFromBar   int
        dataLength     int
        lookbackPeriod int
}

func newBaseIndicator(lookbackPeriod int) *baseIndicator <span class="cov8" title="2995">{
        ind := baseIndicator{lookbackPeriod: lookbackPeriod, validFromBar: -1}
        return &amp;ind
}</span>

func (ind *baseIndicator) ValidFromBar() int <span class="cov5" title="224">{
        return ind.validFromBar
}</span>

func (ind *baseIndicator) GetLookbackPeriod() int <span class="cov10" title="21098">{
        return ind.lookbackPeriod
}</span>

func (ind *baseIndicator) Length() int <span class="cov6" title="310">{
        return ind.dataLength
}</span>

type baseIndicatorWithTimePeriod struct {
        timePeriod int
}

type baseIndicatorWithFloatBounds struct {
        *baseIndicator
        *baseFloatBounds
}

func newBaseIndicatorWithFloatBounds(lookbackPeriod int) *baseIndicatorWithFloatBounds <span class="cov0" title="0">{
        ind := baseIndicatorWithFloatBounds{
                baseIndicator:   newBaseIndicator(lookbackPeriod),
                baseFloatBounds: newBaseFloatBounds()}
        return &amp;ind
}</span>

type baseIndicatorWithIntBounds struct {
        *baseIndicator
        *baseIntBounds
}

func newBaseIndicatorWithIntBounds(lookbackPeriod int) *baseIndicatorWithIntBounds <span class="cov0" title="0">{
        ind := baseIndicatorWithIntBounds{
                baseIndicator: newBaseIndicator(lookbackPeriod),
                baseIntBounds: newBaseIntBounds()}
        return &amp;ind
}</span>

func newBaseIndicatorWithTimePeriod(timePeriod int) *baseIndicatorWithTimePeriod <span class="cov0" title="0">{
        ind := baseIndicatorWithTimePeriod{timePeriod: timePeriod}
        return &amp;ind
}</span>

func (ind *baseIndicatorWithTimePeriod) GetTimePeriod() int <span class="cov0" title="0">{
        return ind.timePeriod
}</span>

type ValueAvailableActionFloat func(dataItem float64, streamBarIndex int)
type ValueAvailableActionInt func(dataItem int64, streamBarIndex int)
type ValueAvailableActionDOHLCV func(dataItem gotrade.DOHLCV, streamBarIndex int)
type ValueAvailableActionBollinger func(dataItemUpperBand float64, dataItemMiddleBand float64, dataItemLowerBand float64, streamBarIndex int)
type ValueAvailableActionMacd func(dataItemMacd float64, dataItemSignal float64, dataItemHistogram float64, streamBarIndex int)
type ValueAvailableActionAroon func(dataItemAroonUp float64, dataItemAroonDown float64, streamBarIndex int)
type ValueAvailableActionStoch func(dataItemK float64, dataItemD float64, streamBarIndex int)
type ValueAvailableActionLinearReg func(dataItem float64, slope float64, intercept float64, streamBarIndex int)
</pre>
		
		<pre class="file" id="file16" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Kaufman Adaptive Moving Average Indicator (Kama), no storage, for use in other indicators
type KamaWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodTotal          float64
        periodHistory        *list.List
        periodCounter        int
        constantMax          float64
        constantDiff         float64
        sumROC               float64
        periodROC            float64
        previousClose        float64
        previousKama         float64
        valueAvailableAction ValueAvailableActionFloat
        timePeriod           int
}

// NewKamaWithoutStorage creates a Kaufman Adaptive Moving Average Indicator (Kama) without storage
func NewKamaWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *KamaWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := KamaWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod + 1) * -1,
                constantMax:          float64(2.0 / (30.0 + 1.0)),
                constantDiff:         float64((2.0 / (2.0 + 1.0)) - (2.0 / (30.0 + 1.0))),
                sumROC:               0.0,
                periodROC:            0.0,
                periodHistory:        list.New(),
                previousClose:        math.SmallestNonzeroFloat64,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Kaufman Adaptive Moving Average Indicator (Kama)
type Kama struct {
        *KamaWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewKama creates a Kaufman Adaptive Moving Average Indicator (Kama) for online usage
func NewKama(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Kama, err error) <span class="cov4" title="22">{
        ind := Kama{selectData: selectData}
        ind.KamaWithoutStorage, err = NewKamaWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1230">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultKama creates a Kaufman Adaptive Moving Average Indicator (Kama) for online usage with default parameters
//        - timePeriod: 25
func NewDefaultKama() (indicator *Kama, err error) <span class="cov0" title="0">{
        timePeriod := 25
        return NewKama(timePeriod, gotrade.UseClosePrice)
}</span>

// NewKamaWithSrcLen creates a Kaufman Adaptive Moving Average Indicator (Kama) for offline usage
func NewKamaWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Kama, err error) <span class="cov0" title="0">{
        ind, err := NewKama(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultKamaWithSrcLen creates a Kaufman Adaptive Moving Average Indicator (Kama) for offline usage with default parameters
func NewDefaultKamaWithSrcLen(sourceLength int) (indicator *Kama, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultKama()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewKamaForStream creates a Kaufman Adaptive Moving Average Indicator (Kama) for online usage with a source data stream
func NewKamaForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Kama, err error) <span class="cov0" title="0">{
        ind, err := NewKama(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultKamaForStream creates a Kaufman Adaptive Moving Average Indicator (Kama) for online usage with a source data stream
func NewDefaultKamaForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Kama, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultKama()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewKamaForStreamWithSrcLen creates a Kaufman Adaptive Moving Average Indicator (Kama) for offline usage with a source data stream
func NewKamaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Kama, err error) <span class="cov0" title="0">{
        ind, err := NewKamaWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultKamaForStreamWithSrcLen creates a Kaufman Adaptive Moving Average Indicator (Kama) for offline usage with a source data stream
func NewDefaultKamaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Kama, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultKamaWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Kama) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1335">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *KamaWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1335">{
        ind.periodCounter += 1
        ind.periodHistory.PushBack(tickData)

        if ind.periodCounter &lt;= 0 </span><span class="cov6" title="118">{
                if ind.previousClose &gt; math.SmallestNonzeroFloat64 </span><span class="cov6" title="101">{
                        ind.sumROC += math.Abs(tickData - ind.previousClose)
                }</span>
        }
        <span class="cov10" title="1335">if ind.periodCounter == 0 </span><span class="cov4" title="13">{
                var er float64 = 0.0
                var sc float64 = 0.0
                var closeMinusN float64 = ind.periodHistory.Front().Value.(float64)
                ind.previousKama = ind.previousClose
                ind.periodROC = tickData - closeMinusN

                // calculate the efficiency ratio
                if ind.sumROC &lt;= ind.periodROC || isZero(ind.sumROC) </span><span class="cov3" title="11">{
                        er = 1.0
                }</span> <span class="cov1" title="2">else {
                        er = math.Abs(ind.periodROC / ind.sumROC)
                }</span>

                <span class="cov4" title="13">sc = (er * ind.constantDiff) + ind.constantMax
                sc *= sc
                ind.previousKama = ((tickData - ind.previousKama) * sc) + ind.previousKama

                result := ind.previousKama

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov4" title="13">if result &gt; ind.maxValue </span><span class="cov4" title="13">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov4" title="13">if result &lt; ind.minValue </span><span class="cov4" title="13">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov4" title="13">ind.valueAvailableAction(result, streamBarIndex)</span>

        } <span class="cov9" title="1322">else if ind.periodCounter &gt; 0 </span><span class="cov9" title="1217">{

                var er float64 = 0.0
                var sc float64 = 0.0
                var closeMinusN float64 = ind.periodHistory.Front().Value.(float64)
                var closeMinusN1 float64 = ind.periodHistory.Front().Next().Value.(float64)
                ind.periodROC = tickData - closeMinusN1

                ind.sumROC -= math.Abs(closeMinusN1 - closeMinusN)
                ind.sumROC += math.Abs(tickData - ind.previousClose)

                // calculate the efficiency ratio
                if ind.sumROC &lt;= ind.periodROC || isZero(ind.sumROC) </span><span class="cov9" title="693">{
                        er = 1.0
                }</span> <span class="cov8" title="524">else {
                        er = math.Abs(ind.periodROC / ind.sumROC)
                }</span>

                <span class="cov9" title="1217">sc = (er * ind.constantDiff) + ind.constantMax
                sc *= sc
                ind.previousKama = ((tickData - ind.previousKama) * sc) + ind.previousKama

                result := ind.previousKama

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                // update the maximum result value
                if result &gt; ind.maxValue </span><span class="cov8" title="329">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="1217">if result &lt; ind.minValue </span><span class="cov6" title="86">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1217">ind.valueAvailableAction(result, streamBarIndex)</span>
        }

        <span class="cov10" title="1335">ind.previousClose = tickData

        if ind.periodHistory.Len() &gt; (ind.timePeriod + 1) </span><span class="cov9" title="1217">{
                var first = ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>

}

func isZero(value float64) bool <span class="cov8" title="526">{
        var epsilon float64 = 0.00000000000001
        return (((-epsilon) &lt; value) &amp;&amp; (value &lt; epsilon))
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Linear Regression Indicator (LinReg), no storage, for use in other indicators
type LinRegWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodCounter        int
        periodHistory        *list.List
        sumX                 float64
        sumXSquare           float64
        divisor              float64
        valueAvailableAction ValueAvailableActionLinearReg
        timePeriod           int
}

// NewLinRegWithoutStorage creates a Linear Regression Indicator (LinReg) without storage
func NewLinRegWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionLinearReg) (indicator *LinRegWithoutStorage, err error) <span class="cov5" title="110">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov5" title="110">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov5" title="110">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>
        <span class="cov5" title="110">lookback := timePeriod - 1
        ind := LinRegWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod) * -1,
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        timePeriodF := float64(timePeriod)
        timePeriodFMinusOne := timePeriodF - 1.0
        ind.sumX = timePeriodF * timePeriodFMinusOne * 0.5
        ind.sumXSquare = timePeriodF * timePeriodFMinusOne * (2.0*timePeriodF - 1.0) / 6.0
        ind.divisor = ind.sumX*ind.sumX - timePeriodF*ind.sumXSquare

        ind.valueAvailableAction = valueAvailableAction

        return &amp;ind, nil</span>
}

// A Linear Regression Indicator (LinReg)
type LinReg struct {
        *LinRegWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewLinReg creates a Linear Regression Indicator (LinReg) for online usage
func NewLinReg(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinReg, err error) <span class="cov3" title="22">{
        ind := LinReg{selectData: selectData}
        ind.LinRegWithoutStorage, err = NewLinRegWithoutStorage(timePeriod,
                func(dataItem float64, slope float64, intercept float64, streamBarIndex int) </span><span class="cov7" title="1271">{
                        ind.Data = append(ind.Data, dataItem)

                        // update the maximum result value
                        if dataItem &gt; ind.LinRegWithoutStorage.maxValue </span><span class="cov5" title="219">{
                                ind.LinRegWithoutStorage.maxValue = dataItem
                        }</span>

                        // update the minimum result value
                        <span class="cov7" title="1271">if dataItem &lt; ind.LinRegWithoutStorage.minValue </span><span class="cov4" title="43">{
                                ind.LinRegWithoutStorage.minValue = dataItem
                        }</span>
                })

        <span class="cov3" title="22">return &amp;ind, err</span>
}

// NewDefaultLinReg creates a Linear Regression Indicator (LinReg) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultLinReg() (indicator *LinReg, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewLinReg(timePeriod, gotrade.UseClosePrice)
}</span>

// NewLinRegWithSrcLen creates a Linear Regression Indicator (LinReg) for offline usage
func NewLinRegWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinReg, err error) <span class="cov0" title="0">{
        ind, err := NewLinReg(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultLinRegWithSrcLen creates a Linear Regression Indicator (LinReg) for offline usage with default parameters
func NewDefaultLinRegWithSrcLen(sourceLength int) (indicator *LinReg, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinReg()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewLinRegForStream creates a Linear Regression Indicator (LinReg) for online usage with a source data stream
func NewLinRegForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinReg, err error) <span class="cov0" title="0">{
        ind, err := NewLinReg(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLinRegForStream creates a Linear Regression Indicator (LinReg) for online usage with a source data stream
func NewDefaultLinRegForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LinReg, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinReg()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewLinRegForStreamWithSrcLen creates a Linear Regression Indicator (LinReg) for offline usage with a source data stream
func NewLinRegForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinReg, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLinRegForStreamWithSrcLen creates a Linear Regression Indicator (LinReg) for offline usage with a source data stream
func NewDefaultLinRegForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LinReg, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *LinReg) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov7" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *LinRegWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov8" title="6635">{
        ind.periodCounter += 1

        if ind.periodCounter &gt;= 0 </span><span class="cov8" title="6355">{
                sumXY := 0.0
                sumY := 0.0
                i := ind.timePeriod
                var value float64 = 0.0
                for e := ind.periodHistory.Front(); e != nil; e = e.Next() </span><span class="cov10" title="38890">{
                        i--
                        value = e.Value.(float64)
                        sumY += value
                        sumXY += (float64(i) * value)
                }</span>
                <span class="cov8" title="6355">sumY += tickData
                timePeriod := float64(ind.timePeriod)
                m := (timePeriod*sumXY - ind.sumX*sumY) / ind.divisor
                b := (sumY - m*ind.sumX) / timePeriod
                result := b + m*float64(timePeriod-1.0)

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="65">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // notify of a new result value though the value available action
                <span class="cov8" title="6355">ind.valueAvailableAction(result, m, b, streamBarIndex)</span>
        }

        <span class="cov8" title="6635">ind.periodHistory.PushBack(tickData)

        if ind.periodHistory.Len() &gt;= ind.timePeriod </span><span class="cov8" title="6355">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">package indicators

import (
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Linear Regression Angle Indicator (LinRegAng)
type LinRegAng struct {
        *LinRegWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewLinRegAng creates a Linear Regression Angle Indicator (LinRegAng) for online usage
func NewLinRegAng(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegAng, err error) <span class="cov4" title="22">{
        ind := LinRegAng{selectData: selectData}
        ind.LinRegWithoutStorage, err = NewLinRegWithoutStorage(timePeriod,
                func(dataItem float64, slope float64, intercept float64, streamBarIndex int) </span><span class="cov9" title="1271">{
                        result := math.Atan(slope) * (180.0 / math.Pi)

                        // update the maximum result value
                        if result &gt; ind.LinRegWithoutStorage.maxValue </span><span class="cov5" title="47">{
                                ind.LinRegWithoutStorage.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov9" title="1271">if result &lt; ind.LinRegWithoutStorage.minValue </span><span class="cov5" title="54">{
                                ind.LinRegWithoutStorage.minValue = result
                        }</span>

                        <span class="cov9" title="1271">ind.Data = append(ind.Data, result)</span>
                })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultLinRegAng creates a Linear Regression Angle Indicator (LinRegAng) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultLinRegAng() (indicator *LinRegAng, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewLinRegAng(timePeriod, gotrade.UseClosePrice)
}</span>

// NewLinRegAngWithSrcLen creates a Linear Regression Angle Indicator (LinRegAng) for offline usage
func NewLinRegAngWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegAng, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegAng(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultLinRegAngWithSrcLen creates a Linear Regression Angle Indicator (LinRegAng) for offline usage with default parameters
func NewDefaultLinRegAngWithSrcLen(sourceLength int) (indicator *LinRegAng, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegAng()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewLinRegAngForStream creates a Linear Regression Angle Indicator (LinRegAng) for online usage with a source data stream
func NewLinRegAngForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegAng, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegAng(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLinRegAngForStream creates a Linear Regression Angle Indicator (LinRegAng) for online usage with a source data stream
func NewDefaultLinRegAngForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LinRegAng, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegAng()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewLinRegAngForStreamWithSrcLen creates a Linear Regression Angle Indicator (LinRegAng) for offline usage with a source data stream
func NewLinRegAngForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegAng, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegAngWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLinRegAngForStreamWithSrcLen creates a Linear Regression Angle Indicator (LinRegAng) for offline usage with a source data stream
func NewDefaultLinRegAngForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LinRegAng, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegAngWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *LinRegAng) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package indicators

import (
        "github.com/thetruetrade/gotrade"
)

// A Linear Regression Intercept Indicator (LinRegInt)
type LinRegInt struct {
        *LinRegWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewLinRegInt creates a Linear Regression Intercept Indicator (LinRegInt) for online usage
func NewLinRegInt(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegInt, err error) <span class="cov4" title="22">{
        ind := LinRegInt{selectData: selectData}
        ind.LinRegWithoutStorage, err = NewLinRegWithoutStorage(timePeriod,
                func(dataItem float64, slope float64, intercept float64, streamBarIndex int) </span><span class="cov9" title="1271">{
                        result := intercept

                        // update the maximum result value
                        if result &gt; ind.LinRegWithoutStorage.maxValue </span><span class="cov7" title="225">{
                                ind.LinRegWithoutStorage.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov9" title="1271">if result &lt; ind.LinRegWithoutStorage.minValue </span><span class="cov6" title="55">{
                                ind.LinRegWithoutStorage.minValue = result
                        }</span>

                        <span class="cov9" title="1271">ind.Data = append(ind.Data, result)</span>
                })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultLinRegInt creates a Linear Regression Intercept Indicator (LinRegInt) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultLinRegInt() (indicator *LinRegInt, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewLinRegInt(timePeriod, gotrade.UseClosePrice)
}</span>

// NewLinRegIntWithSrcLen creates a Linear Regression Intercept Indicator (LinRegInt) for offline usage
func NewLinRegIntWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegInt, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegInt(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultLinRegIntWithSrcLen creates a Linear Regression Intercept Indicator (LinRegInt) for offline usage with default parameters
func NewDefaultLinRegIntWithSrcLen(sourceLength int) (indicator *LinRegInt, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegInt()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewLinRegIntForStream creates a Linear Regression Intercept Indicator (LinRegInt) for online usage with a source data stream
func NewLinRegIntForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegInt, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegInt(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLinRegIntForStream creates a Linear Regression Intercept Indicator (LinRegInt) for online usage with a source data stream
func NewDefaultLinRegIntForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LinRegInt, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegInt()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewLinRegIntForStreamWithSrcLen creates a Linear Regression Intercept Indicator (LinRegInt) for offline usage with a source data stream
func NewLinRegIntForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegInt, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegIntWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLinRegIntForStreamWithSrcLen creates a Linear Regression Intercept Indicator (LinRegInt) for offline usage with a source data stream
func NewDefaultLinRegIntForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LinRegInt, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegIntWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *LinRegInt) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package indicators

import (
        "github.com/thetruetrade/gotrade"
)

// A Linear Regression Intercept Indicator (LinRegInt)
type LinRegSlp struct {
        *LinRegWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewLinRegSlp creates a Linear Regression Slope Indicator (LinRegSlp) for online usage
func NewLinRegSlp(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegSlp, err error) <span class="cov4" title="22">{
        ind := LinRegSlp{selectData: selectData}
        ind.LinRegWithoutStorage, err = NewLinRegWithoutStorage(timePeriod,
                func(dataItem float64, slope float64, intercept float64, streamBarIndex int) </span><span class="cov9" title="1271">{
                        result := slope

                        // update the maximum result value
                        if result &gt; ind.LinRegWithoutStorage.maxValue </span><span class="cov5" title="47">{
                                ind.LinRegWithoutStorage.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov9" title="1271">if result &lt; ind.LinRegWithoutStorage.minValue </span><span class="cov5" title="54">{
                                ind.LinRegWithoutStorage.minValue = result
                        }</span>

                        <span class="cov9" title="1271">ind.Data = append(ind.Data, result)</span>
                })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultLinRegSlp creates a Linear Regression Slope Indicator (LinRegSlp) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultLinRegSlp() (indicator *LinRegSlp, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewLinRegSlp(timePeriod, gotrade.UseClosePrice)
}</span>

// NewLinRegSlpWithSrcLen creates a Linear Regression Slope Indicator (LinRegSlp) for offline usage
func NewLinRegSlpWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegSlp, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegSlp(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultLinRegSlpWithSrcLen creates a Linear Regression Slope Indicator (LinRegSlp) for offline usage with default parameters
func NewDefaultLinRegSlpWithSrcLen(sourceLength int) (indicator *LinRegSlp, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegSlp()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewLinRegSlpForStream creates a Linear Regression Slope Indicator (LinRegSlp) for online usage with a source data stream
func NewLinRegSlpForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegSlp, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegSlp(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLinRegSlpForStream creates a Linear Regression Slope Indicator (LinRegSlp) for online usage with a source data stream
func NewDefaultLinRegSlpForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LinRegSlp, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegSlp()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewLinRegSlpForStreamWithSrcLen creates a Linear Regression Slope Indicator (LinRegSlp) for offline usage with a source data stream
func NewLinRegSlpForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LinRegSlp, err error) <span class="cov0" title="0">{
        ind, err := NewLinRegSlpWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLinRegSlpForStreamWithSrcLen creates a Linear Regression Slope Indicator (LinRegSlp) for offline usage with a source data stream
func NewDefaultLinRegSlpForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LinRegSlp, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLinRegSlpWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *LinRegSlp) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Lowest Low Value Indicator (Llv), no storage, for use in other indicators
type LlvWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodHistory        *list.List
        valueAvailableAction ValueAvailableActionFloat
        currentLow           float64
        currentLowIndex      int
        timePeriod           int
}

// NewLlvWithoutStorage creates a Lowest Low Value Indicator Indicator (Llv) without storage
func NewLlvWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *LlvWithoutStorage, err error) <span class="cov4" title="45">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov4" title="45">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="45">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="45">lookback := timePeriod - 1
        ind := LlvWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                currentLow:           math.MaxFloat64,
                currentLowIndex:      0,
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Lowest Low Value Indicator (hhv)
type Llv struct {
        *LlvWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewLlv creates a Lowest Low Value Indicator (Llv) for online usage
func NewLlv(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Llv, err error) <span class="cov4" title="22">{
        ind := Llv{selectData: selectData}
        ind.LlvWithoutStorage, err = NewLlvWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov8" title="1271">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultLlv creates a Lowest Low Value Indicator (Llv) for online usage with default parameters
//        - timePeriod: 25
func NewDefaultLlv() (indicator *Llv, err error) <span class="cov0" title="0">{
        timePeriod := 25
        return NewLlv(timePeriod, gotrade.UseClosePrice)
}</span>

// NewLlvWithSrcLen creates a Lowest Low Value Indicator (Llv)for offline usage
func NewLlvWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Llv, err error) <span class="cov0" title="0">{
        ind, err := NewLlv(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultLlvWithSrcLen creates a Lowest Low Value Indicator (Llv)for offline usage with default parameters
func NewDefaultLlvWithSrcLen(sourceLength int) (indicator *Llv, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLlv()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewLlvForStream creates a Lowest Low Value Indicator (Llv)for online usage with a source data stream
func NewLlvForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Llv, err error) <span class="cov0" title="0">{
        ind, err := NewLlv(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLlvForStream creates a Lowest Low Value Indicator (Llv)for online usage with a source data stream
func NewDefaultLlvForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Llv, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLlv()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewLlvForStreamWithSrcLen creates a Lowest Low Value Indicator (Llv)for offline usage with a source data stream
func NewLlvForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Llv, err error) <span class="cov0" title="0">{
        ind, err := NewLlvWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLlvForStreamWithSrcLen creates a Lowest Low Value Indicator (Llv)for offline usage with a source data stream
func NewDefaultLlvForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Llv, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLlvWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Llv) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov8" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *LlvWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov8" title="2953">{
        ind.periodHistory.PushBack(tickData)

        // resize the history
        if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov8" title="2794">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)

                // make sure we haven't just removed the current low
                if ind.currentLowIndex == ind.timePeriod-1 </span><span class="cov8" title="1798">{
                        ind.currentLow = math.MaxFloat64
                        // we have we need to find the new low in the history
                        var i int = ind.timePeriod - 1
                        for e := ind.periodHistory.Front(); e != nil; e = e.Next() </span><span class="cov10" title="8398">{
                                value := e.Value.(float64)
                                if value &lt; ind.currentLow </span><span class="cov8" title="2039">{
                                        ind.currentLow = value
                                        ind.currentLowIndex = i
                                }</span>
                                <span class="cov10" title="8398">i -= 1</span>
                        }
                } <span class="cov7" title="996">else {
                        if tickData &lt; ind.currentLow </span><span class="cov6" title="182">{
                                ind.currentLow = tickData
                                ind.currentLowIndex = 0
                        }</span> <span class="cov7" title="814">else {
                                ind.currentLowIndex += 1
                        }</span>
                }

                <span class="cov8" title="2794">var result = ind.currentLow

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov0" title="0">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov8" title="2794">if result &gt; ind.maxValue </span><span class="cov6" title="393">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov8" title="2794">if result &lt; ind.minValue </span><span class="cov4" title="36">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov8" title="2794">ind.valueAvailableAction(result, streamBarIndex)</span>

        } <span class="cov6" title="159">else {
                if tickData &lt; ind.currentLow </span><span class="cov4" title="39">{
                        ind.currentLow = tickData
                        ind.currentLowIndex = 0
                }</span> <span class="cov5" title="120">else {
                        ind.currentLowIndex += 1
                }</span>

                <span class="cov6" title="159">if ind.periodHistory.Len() == ind.timePeriod </span><span class="cov4" title="31">{
                        var result = ind.currentLow

                        // increment the number of results this indicator can be expected to return
                        ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov4" title="31">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        // update the maximum result value
                        <span class="cov4" title="31">if result &gt; ind.maxValue </span><span class="cov3" title="16">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov4" title="31">if result &lt; ind.minValue </span><span class="cov4" title="31">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov4" title="31">ind.valueAvailableAction(result, streamBarIndex)</span>
                }
        }

}
</pre>
		
		<pre class="file" id="file22" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Lowest Low Value Bars Indicator (LlvBars), no storage, for use in other indicators
type LlvBarsWithoutStorage struct {
        *baseIndicator
        *baseIntBounds

        // private variables
        periodHistory        *list.List
        valueAvailableAction ValueAvailableActionInt
        currentLow           float64
        currentLowIndex      int64
        timePeriod           int
}

// NewLlvBarsWithoutStorage creates a Lowest Low Value Bars Indicator Indicator (LlvBars) without storage
func NewLlvBarsWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionInt) (indicator *LlvBarsWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov4" title="22">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod - 1

        ind := LlvBarsWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseIntBounds:        newBaseIntBounds(),
                currentLow:           math.MaxFloat64,
                currentLowIndex:      0,
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Lowest Low Value Bars Indicator (LlvBars)
type LlvBars struct {
        *LlvBarsWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []int64
}

// NewLlvBars creates a Lowest Low Value Bars Indicator (LlvBars) for online usage
func NewLlvBars(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LlvBars, err error) <span class="cov4" title="22">{
        ind := LlvBars{selectData: selectData}
        ind.LlvBarsWithoutStorage, err = NewLlvBarsWithoutStorage(timePeriod, func(dataItem int64, streamBarIndex int) </span><span class="cov8" title="1271">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultLlvBars creates a Lowest Low Value Indicator (LlvBars) for online usage with default parameters
//        - timePeriod: 25
func NewDefaultLlvBars() (indicator *LlvBars, err error) <span class="cov0" title="0">{
        timePeriod := 25
        return NewLlvBars(timePeriod, gotrade.UseClosePrice)
}</span>

// NewLlvBarsWithSrcLen creates a Lowest Low Value Indicator (LlvBars)for offline usage
func NewLlvBarsWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LlvBars, err error) <span class="cov0" title="0">{
        ind, err := NewLlvBars(timePeriod, selectData)
        ind.Data = make([]int64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultLlvBarsWithSrcLen creates a Lowest Low Value Indicator (LlvBars)for offline usage with default parameters
func NewDefaultLlvBarsWithSrcLen(sourceLength int) (indicator *LlvBars, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLlvBars()
        ind.Data = make([]int64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewLlvBarsForStream creates a Lowest Low Value Indicator (LlvBars)for online usage with a source data stream
func NewLlvBarsForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LlvBars, err error) <span class="cov0" title="0">{
        ind, err := NewLlvBars(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLlvBarsForStream creates a Lowest Low Value Indicator (LlvBars)for online usage with a source data stream
func NewDefaultLlvBarsForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LlvBars, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLlvBars()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewLlvBarsForStreamWithSrcLen creates a Lowest Low Value Indicator (LlvBars)for offline usage with a source data stream
func NewLlvBarsForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *LlvBars, err error) <span class="cov0" title="0">{
        ind, err := NewLlvBarsWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultLlvBarsForStreamWithSrcLen creates a Lowest Low Value Indicator (LlvBars)for offline usage with a source data stream
func NewDefaultLlvBarsForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *LlvBars, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultLlvBarsWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *LlvBars) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov8" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *LlvBarsWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov8" title="1327">{
        ind.periodHistory.PushBack(tickData)

        // resize the history
        if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov8" title="1258">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)

                // make sure we haven't just removed the current low
                if ind.currentLowIndex == int64(ind.timePeriod-1) </span><span class="cov8" title="824">{
                        ind.currentLow = math.MaxFloat64
                        // we have we need to find the new low in the history
                        var i int = ind.timePeriod - 1
                        for e := ind.periodHistory.Front(); e != nil; e = e.Next() </span><span class="cov10" title="3528">{
                                value := e.Value.(float64)
                                if value &lt; ind.currentLow </span><span class="cov8" title="914">{
                                        ind.currentLow = value
                                        ind.currentLowIndex = int64(i)
                                }</span>
                                <span class="cov10" title="3528">i -= 1</span>
                        }
                } <span class="cov7" title="434">else {
                        if tickData &lt; ind.currentLow </span><span class="cov5" title="50">{
                                ind.currentLow = tickData
                                ind.currentLowIndex = 0
                        }</span> <span class="cov7" title="384">else {
                                ind.currentLowIndex += 1
                        }</span>
                }

                <span class="cov8" title="1258">var result = ind.currentLowIndex

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov0" title="0">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov8" title="1258">if result &gt; ind.maxValue </span><span class="cov4" title="20">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov8" title="1258">if result &lt; ind.minValue </span><span class="cov3" title="11">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov8" title="1258">ind.valueAvailableAction(result, streamBarIndex)</span>

        } <span class="cov5" title="69">else {
                if tickData &lt; ind.currentLow </span><span class="cov4" title="21">{
                        ind.currentLow = tickData
                        ind.currentLowIndex = 0
                }</span> <span class="cov5" title="48">else {
                        ind.currentLowIndex += 1
                }</span>

                <span class="cov5" title="69">if ind.periodHistory.Len() == ind.timePeriod </span><span class="cov3" title="13">{
                        var result = ind.currentLowIndex

                        // increment the number of results this indicator can be expected to return
                        ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov3" title="13">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        // update the maximum result value
                        <span class="cov3" title="13">if result &gt; ind.maxValue </span><span class="cov3" title="13">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov3" title="13">if result &lt; ind.minValue </span><span class="cov3" title="13">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov3" title="13">ind.valueAvailableAction(result, streamBarIndex)</span>
                }
        }

}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Moving Average Convergence and Divergence (Macd)
package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Moving Average Convergence-Divergence (Macd) Indicator
type Macd struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionMacd
        fastTimePeriod       int
        slowTimePeriod       int
        signalTimePeriod     int
        emaFast              *EmaWithoutStorage
        emaSlow              *EmaWithoutStorage
        emaSignal            *EmaWithoutStorage
        currentFastEma       float64
        currentSlowEma       float64
        currentMacd          float64
        emaSlowSkip          int
        selectData           gotrade.DataSelectionFunc

        // public variables
        Macd      []float64
        Signal    []float64
        Histogram []float64
}

// NewMacd creates a Moving Average Convergence Divergence Indicator (Macd) for online usage
func NewMacd(fastTimePeriod int, slowTimePeriod int, signalTimePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Macd, err error) <span class="cov4" title="22">{

        // the minimum fastTimePeriod for this indicator is 2
        if fastTimePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("fastTimePeriod is less than the minimum (2)")
        }</span>

        // check the maximum fastTimePeriod
        <span class="cov4" title="22">if fastTimePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("fastTimePeriod is greater than the maximum (100000)")
        }</span>

        // the minimum slowTimePeriod for this indicator is 2
        <span class="cov4" title="22">if slowTimePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("slowTimePeriod is less than the minimum (2)")
        }</span>

        // check the maximum slowTimePeriod
        <span class="cov4" title="22">if slowTimePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("slowTimePeriod is greater than the maximum (100000)")
        }</span>

        // the minimum signalTimePeriod for this indicator is 2
        <span class="cov4" title="22">if signalTimePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("signalTimePeriod is less than the minimum (2)")
        }</span>

        // check the maximum slowTimePeriod
        <span class="cov4" title="22">if signalTimePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("signalTimePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := slowTimePeriod + signalTimePeriod - 2
        ind := Macd{
                baseIndicator:    newBaseIndicator(lookback),
                baseFloatBounds:  newBaseFloatBounds(),
                fastTimePeriod:   fastTimePeriod,
                slowTimePeriod:   slowTimePeriod,
                signalTimePeriod: signalTimePeriod,
        }

        // shift the fast ema up so that it has valid data at the same time as the slow emas
        ind.emaSlowSkip = slowTimePeriod - fastTimePeriod
        ind.emaFast, err = NewEmaWithoutStorage(fastTimePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1234">{
                ind.currentFastEma = dataItem
        }</span>)

        <span class="cov4" title="22">ind.emaSlow, err = NewEmaWithoutStorage(slowTimePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1234">{
                ind.currentSlowEma = dataItem

                ind.currentMacd = ind.currentFastEma - ind.currentSlowEma

                ind.emaSignal.ReceiveTick(ind.currentMacd, streamBarIndex)
        }</span>)

        <span class="cov4" title="22">ind.emaSignal, err = NewEmaWithoutStorage(signalTimePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1203">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // Macd Line: (12-day EmaWithoutStorage - 26-day EmaWithoutStorage)

                // Signal Line: 9-day EmaWithoutStorage of Macd Line

                // Macd Histogram: Macd Line - Signal Line

                <span class="cov9" title="1203">macd := ind.currentFastEma - ind.currentSlowEma
                signal := dataItem
                histogram := macd - signal

                // update the maximum result value
                if macd &gt; ind.maxValue </span><span class="cov5" title="31">{
                        ind.maxValue = macd
                }</span>

                <span class="cov9" title="1203">if signal &gt; ind.maxValue </span><span class="cov1" title="2">{
                        ind.maxValue = signal
                }</span>

                <span class="cov9" title="1203">if histogram &gt; ind.maxValue </span><span class="cov2" title="4">{
                        ind.maxValue = histogram
                }</span>

                // update the minimum result value
                <span class="cov9" title="1203">if macd &lt; ind.minValue </span><span class="cov5" title="49">{
                        ind.minValue = macd
                }</span>

                <span class="cov9" title="1203">if signal &lt; ind.minValue </span><span class="cov0" title="0">{
                        ind.minValue = signal
                }</span>

                <span class="cov9" title="1203">if histogram &lt; ind.minValue </span><span class="cov5" title="46">{
                        ind.minValue = histogram
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1203">ind.valueAvailableAction(macd, signal, histogram, streamBarIndex)</span>
        })

        <span class="cov4" title="22">ind.selectData = selectData
        ind.valueAvailableAction = func(dataItemMacd float64, dataItemSignal float64, dataItemHistogram float64, streamBarIndex int) </span><span class="cov9" title="1203">{
                ind.Macd = append(ind.Macd, dataItemMacd)
                ind.Signal = append(ind.Signal, dataItemSignal)
                ind.Histogram = append(ind.Histogram, dataItemHistogram)
        }</span>
        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultMacd creates a Moving Average Convergence Divergence Indicator (Macd) for online usage with default parameters
//        fastTimePeriod - 12
//        slowTimePeriod - 26
//        signalTimePeriod - 9
func NewDefaultMacd() (indicator *Macd, err error) <span class="cov0" title="0">{
        fastTimePeriod := 12
        slowTimePeriod := 26
        signalTimePeriod := 9
        return NewMacd(fastTimePeriod, slowTimePeriod, signalTimePeriod, gotrade.UseClosePrice)
}</span>

// NewMacdWithSrcLen creates a Moving Average Convergence Divergence Indicator (Macd) for offline usage
func NewMacdWithSrcLen(sourceLength int, fastTimePeriod int, slowTimePeriod int, signalTimePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Macd, err error) <span class="cov0" title="0">{
        ind, err := NewMacd(fastTimePeriod, slowTimePeriod, signalTimePeriod, selectData)
        ind.Macd = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.Signal = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.Histogram = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultMacdWithSrcLen creates a Moving Average Convergence Divergence Indicator (Macd) for offline usage with default parameters
func NewDefaultMacdWithSrcLen(sourceLength int) (indicator *Macd, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMacd()
        ind.Macd = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.Signal = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.Histogram = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewMacdForStream creates a Moving Average Convergence Divergence Indicator (Macd) for online usage with a source data stream
func NewMacdForStream(priceStream gotrade.DOHLCVStreamSubscriber, fastTimePeriod int, slowTimePeriod int, signalTimePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Macd, err error) <span class="cov0" title="0">{
        ind, err := NewMacd(fastTimePeriod, slowTimePeriod, signalTimePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMacdForStream creates a Moving Average Convergence Divergence Indicator (Macd) for online usage with a source data stream
func NewDefaultMacdForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Macd, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMacd()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewMacdForStreamWithSrcLen creates a Moving Average Convergence Divergence Indicator (Macd) for offline usage with a source data stream
func NewMacdForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, fastTimePeriod int, slowTimePeriod int, signalTimePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Macd, err error) <span class="cov0" title="0">{
        ind, err := NewMacdWithSrcLen(sourceLength, fastTimePeriod, slowTimePeriod, signalTimePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMacdForStreamWithSrcLen creates a Moving Average Convergence Divergence Indicator (Macd) for offline usage with a source data stream
func NewDefaultMacdForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Macd, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMacdWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Macd) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1359">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *Macd) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1359">{
        if streamBarIndex &gt; ind.emaSlowSkip </span><span class="cov9" title="1286">{
                ind.emaFast.ReceiveTick(tickData, streamBarIndex)
        }</span>
        <span class="cov10" title="1359">ind.emaSlow.ReceiveTick(tickData, streamBarIndex)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package indicators

import (
        "github.com/thetruetrade/gotrade"
)

// A Median Price Indicator (MedPrice), no storage, for use in other indicators
type MedPriceWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
}

// NewMedPriceWithoutStorage creates a Median Price Indicator (MedPrice) without storage
func NewMedPriceWithoutStorage(valueAvailableAction ValueAvailableActionFloat) (indicator *MedPriceWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        <span class="cov4" title="22">lookback := 0
        ind := MedPriceWithoutStorage{
                baseIndicator:   newBaseIndicator(lookback),
                baseFloatBounds: newBaseFloatBounds(),
        }

        ind.valueAvailableAction = valueAvailableAction

        return &amp;ind, nil</span>
}

// A Median Price Indicator (MedPrice)
type MedPrice struct {
        *MedPriceWithoutStorage

        // public variables
        Data []float64
}

func NewMedPrice() (indicator *MedPrice, err error) <span class="cov4" title="22">{
        ind := MedPrice{}
        ind.MedPriceWithoutStorage, err = NewMedPriceWithoutStorage(func(dataItem float64, streamBarIndex int) </span><span class="cov10" title="1311">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultMedPrice creates a Median Price Indicator (MedPrice) for online usage with default parameters
func NewDefaultMedPrice() (indicator *MedPrice, err error) <span class="cov0" title="0">{
        return NewMedPrice()
}</span>

// NewMedPriceWithSrcLen creates a Median Price Indicator (MedPrice) for offline usage
func NewMedPriceWithSrcLen(sourceLength int) (indicator *MedPrice, err error) <span class="cov0" title="0">{
        ind, err := NewMedPrice()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultMedPriceWithSrcLen creates a Median Price Indicator (MedPrice) for offline usage with default parameters
func NewDefaultMedPriceWithSrcLen(sourceLength int) (indicator *MedPrice, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMedPrice()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewMedPriceForStream creates a Median Price Indicator (MedPrice) for online usage with a source data stream
func NewMedPriceForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *MedPrice, err error) <span class="cov0" title="0">{
        ind, err := NewMedPrice()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMedPriceForStream creates a Median Price Indicator (MedPrice) for online usage with a source data stream
func NewDefaultMedPriceForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *MedPrice, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMedPrice()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewMedPriceForStreamWithSrcLen creates a Median Price Indicator (MedPrice) for offline usage with a source data stream
func NewMedPriceForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *MedPrice, err error) <span class="cov0" title="0">{
        ind, err := NewMedPriceWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMedPriceForStreamWithSrcLen creates a Median Price Indicator (MedPrice) for offline usage with a source data stream
func NewDefaultMedPriceForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *MedPrice, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMedPriceWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *MedPriceWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1311">{

        // increment the number of results this indicator can be expected to return
        ind.dataLength += 1

        if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                // set the streamBarIndex from which this indicator returns valid results
                ind.validFromBar = streamBarIndex
        }</span>

        <span class="cov10" title="1311">result := (tickData.H() + tickData.L()) / float64(2.0)

        // update the maximum result value
        if result &gt; ind.maxValue </span><span class="cov7" title="195">{
                ind.maxValue = result
        }</span>

        // update the minimum result value
        <span class="cov10" title="1311">if result &lt; ind.minValue </span><span class="cov5" title="29">{
                ind.minValue = result
        }</span>

        // notify of a new result value though the value available action
        <span class="cov10" title="1311">ind.valueAvailableAction(result, streamBarIndex)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Money Flow Index Indicator (Mfi), no storage, for use in other indicators
type MfiWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        typicalPrice         *TypPriceWithoutStorage
        positiveMoneyFlow    float64
        negativeMoneyFlow    float64
        positiveHistory      *list.List
        negativeHistory      *list.List
        previousTypPrice     float64
        currentVolume        float64
        timePeriod           int
}

// NewMfiWithoutStorage creates a Money Flow Index Indicator (Mfi) without storage
func NewMfiWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *MfiWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := MfiWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod * -1) - 1,
                positiveHistory:      list.New(),
                negativeHistory:      list.New(),
                positiveMoneyFlow:    0.0,
                negativeMoneyFlow:    0.0,
                currentVolume:        0.0,
                previousTypPrice:     0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.typicalPrice, err = NewTypPriceWithoutStorage(func(dataItem float64, streamBarIndex int) </span><span class="cov10" title="1423">{
                ind.periodCounter += 1

                if ind.periodCounter &gt; (ind.timePeriod * -1) </span><span class="cov9" title="1406">{
                        moneyFlow := dataItem * ind.currentVolume

                        if ind.periodCounter &lt;= 0 </span><span class="cov7" title="234">{
                                if dataItem &gt; ind.previousTypPrice </span><span class="cov7" title="216">{
                                        ind.positiveMoneyFlow += moneyFlow
                                        ind.positiveHistory.PushBack(moneyFlow)
                                        ind.negativeHistory.PushBack(0.0)
                                }</span> <span class="cov4" title="18">else if dataItem &lt; ind.previousTypPrice </span><span class="cov4" title="18">{
                                        ind.negativeMoneyFlow += moneyFlow
                                        ind.positiveHistory.PushBack(0.0)
                                        ind.negativeHistory.PushBack(moneyFlow)
                                }</span> <span class="cov0" title="0">else {
                                        ind.positiveHistory.PushBack(0.0)
                                        ind.negativeHistory.PushBack(0.0)
                                }</span>
                        }

                        <span class="cov9" title="1406">if ind.periodCounter == 0 </span><span class="cov4" title="13">{

                                result := 100.0 * (ind.positiveMoneyFlow / (ind.positiveMoneyFlow + ind.negativeMoneyFlow))

                                // increment the number of results this indicator can be expected to return
                                ind.dataLength += 1
                                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                                        // set the streamBarIndex from which this indicator returns valid results
                                        ind.validFromBar = streamBarIndex
                                }</span>

                                // update the maximum result value
                                <span class="cov4" title="13">if result &gt; ind.maxValue </span><span class="cov1" title="2">{
                                        ind.maxValue = result
                                }</span>

                                // update the minimum result value
                                <span class="cov4" title="13">if result &lt; ind.minValue </span><span class="cov1" title="2">{
                                        ind.minValue = result
                                }</span>

                                // notify of a new result value though the value available action
                                <span class="cov4" title="13">ind.valueAvailableAction(result, streamBarIndex)</span>
                        }
                        <span class="cov9" title="1406">if ind.periodCounter &gt; 0 </span><span class="cov9" title="1172">{
                                firstPositive := ind.positiveHistory.Front().Value.(float64)
                                ind.positiveMoneyFlow -= firstPositive

                                firstNegative := ind.negativeHistory.Front().Value.(float64)
                                ind.negativeMoneyFlow -= firstNegative

                                if dataItem &gt; ind.previousTypPrice </span><span class="cov8" title="479">{
                                        ind.positiveMoneyFlow += moneyFlow
                                        ind.positiveHistory.PushBack(moneyFlow)
                                        ind.negativeHistory.PushBack(0.0)
                                }</span> <span class="cov9" title="693">else if dataItem &lt; ind.previousTypPrice </span><span class="cov7" title="222">{
                                        ind.negativeMoneyFlow += moneyFlow
                                        ind.positiveHistory.PushBack(0.0)
                                        ind.negativeHistory.PushBack(moneyFlow)
                                }</span> <span class="cov8" title="471">else {
                                        ind.positiveHistory.PushBack(0.0)
                                        ind.negativeHistory.PushBack(0.0)
                                }</span>

                                <span class="cov9" title="1172">result := 100.0 * (ind.positiveMoneyFlow / (ind.positiveMoneyFlow + ind.negativeMoneyFlow))

                                // increment the number of results this indicator can be expected to return
                                ind.dataLength += 1

                                // update the maximum result value
                                if result &gt; ind.maxValue </span><span class="cov5" title="26">{
                                        ind.maxValue = result
                                }</span>

                                // update the minimum result value
                                <span class="cov9" title="1172">if result &lt; ind.minValue </span><span class="cov3" title="10">{
                                        ind.minValue = result
                                }</span>

                                // notify of a new result value though the value available action
                                <span class="cov9" title="1172">ind.valueAvailableAction(result, streamBarIndex)</span>
                        }

                }
                <span class="cov10" title="1423">ind.previousTypPrice = dataItem

                if ind.positiveHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="1172">{
                        first := ind.positiveHistory.Front()
                        ind.positiveHistory.Remove(first)
                }</span>

                <span class="cov10" title="1423">if ind.negativeHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="1172">{
                        first := ind.negativeHistory.Front()
                        ind.negativeHistory.Remove(first)
                }</span>
        })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// A Money Flow Index Indicator (Mfi)
type Mfi struct {
        *MfiWithoutStorage

        // public variables
        Data []float64
}

// NewMfi creates a Money Flow Index Indicator (Mfi) for online usage
func NewMfi(timePeriod int) (indicator *Mfi, err error) <span class="cov4" title="22">{
        ind := Mfi{}
        ind.MfiWithoutStorage, err = NewMfiWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1185">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultMfi creates a Money Flow Index Indicator (Mfi) for online usage with default parameters
//        - timePeriod: 25
func NewDefaultMfi() (indicator *Mfi, err error) <span class="cov0" title="0">{
        timePeriod := 25
        return NewMfi(timePeriod)
}</span>

// NewMfiWithSrcLen creates a Money Flow Index Indicator (Mfi) for offline usage
func NewMfiWithSrcLen(sourceLength int, timePeriod int) (indicator *Mfi, err error) <span class="cov0" title="0">{
        ind, err := NewMfi(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultMfiWithSrcLen creates a Money Flow Index Indicator (Mfi) for offline usage with default parameters
func NewDefaultMfiWithSrcLen(sourceLength int) (indicator *Mfi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMfi()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewMfiForStream creates a Money Flow Index Indicator (Mfi) for online usage with a source data stream
func NewMfiForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Mfi, err error) <span class="cov0" title="0">{
        ind, err := NewMfi(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMfiForStream creates a Money Flow Index Indicator (Mfi) for online usage with a source data stream
func NewDefaultMfiForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Mfi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMfi()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewMfiForStreamWithSrcLen creates a Money Flow Index Indicator (Mfi) for offline usage with a source data stream
func NewMfiForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *Mfi, err error) <span class="cov0" title="0">{
        ind, err := NewMfiWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMfiForStreamWithSrcLen creates a Money Flow Index Indicator (Mfi) for offline usage with a source data stream
func NewDefaultMfiForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Mfi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMfiWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *MfiWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1423">{
        ind.currentVolume = tickData.V()
        ind.typicalPrice.ReceiveDOHLCVTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Minus Directional Indicator (MinusDi), no storage, for use in other indicators
type MinusDiWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        previousHigh         float64
        previousLow          float64
        previousMinusDM      float64
        previousTrueRange    float64
        currentTrueRange     float64
        trueRange            *TrueRange
        timePeriod           int
}

// NewMinusDiWithoutStorage creates a Minus Directional Indicator (MinusDi) without storage
func NewMinusDiWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *MinusDiWithoutStorage, err error) <span class="cov6" title="240">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov6" title="240">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov6" title="240">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov6" title="240">lookback := 1
        if timePeriod &gt; 1 </span><span class="cov6" title="238">{
                lookback = timePeriod
        }</span>
        <span class="cov6" title="240">ind := MinusDiWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        -1,
                previousMinusDM:      0.0,
                previousTrueRange:    0.0,
                currentTrueRange:     0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.trueRange, err = NewTrueRange()

        ind.trueRange.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov10" title="13832">{
                ind.currentTrueRange = dataItem
        }</span>

        <span class="cov6" title="240">return &amp;ind, nil</span>
}

// A Minus Directional Indicator (MinusDi)
type MinusDi struct {
        *MinusDiWithoutStorage

        // public variables
        Data []float64
}

// NewMinusDi creates a Minus Directional Indicator (MinusDi) for online usage
func NewMinusDi(timePeriod int) (indicator *MinusDi, err error) <span class="cov6" title="240">{
        ind := MinusDi{}
        ind.MinusDiWithoutStorage, err = NewMinusDiWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov8" title="1685">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov6" title="240">return &amp;ind, err</span>
}

// NewDefaultMinusDi creates a Minus Directional Indicator (MinusDi) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultMinusDi() (indicator *MinusDi, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewMinusDi(timePeriod)
}</span>

// NewMinusDiWithSrcLen creates a Minus Directional Indicator (MinusDi) for offline usage
func NewMinusDiWithSrcLen(sourceLength int, timePeriod int) (indicator *MinusDi, err error) <span class="cov0" title="0">{
        ind, err := NewMinusDi(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultMinusDiWithSrcLen creates a Minus Directional Indicator (MinusDi) for offline usage with default parameters
func NewDefaultMinusDiWithSrcLen(sourceLength int) (indicator *MinusDi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMinusDi()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewMinusDiForStream creates a Minus Directional Indicator (MinusDi) for online usage with a source data stream
func NewMinusDiForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *MinusDi, err error) <span class="cov0" title="0">{
        ind, err := NewMinusDi(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMinusDiForStream creates a Minus Directional Indicator (MinusDi) for online usage with a source data stream
func NewDefaultMinusDiForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *MinusDi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMinusDi()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewMinusDiForStreamWithSrcLen creates a Minus Directional Indicator (MinusDi) for offline usage with a source data stream
func NewMinusDiForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *MinusDi, err error) <span class="cov0" title="0">{
        ind, err := NewMinusDiWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMinusDiForStreamWithSrcLen creates a Minus Directional Indicator (MinusDi) for offline usage with a source data stream
func NewDefaultMinusDiForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *MinusDi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMinusDiWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *MinusDiWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov9" title="13466">{

        // forward to the true range indicator first using previous data
        ind.trueRange.ReceiveDOHLCVTick(tickData, streamBarIndex)

        ind.periodCounter += 1
        high := tickData.H()
        low := tickData.L()
        diffP := high - ind.previousHigh
        diffM := ind.previousLow - low

        if ind.lookbackPeriod == 1 </span><span class="cov6" title="502">{
                if ind.periodCounter &gt; 0 </span><span class="cov6" title="500">{

                        // forward to the true range indicator first using previous data
                        ind.trueRange.ReceiveDOHLCVTick(tickData, streamBarIndex)

                        var result float64
                        if (diffM &gt; 0) &amp;&amp; (diffP &lt; diffM) &amp;&amp; ind.currentTrueRange != 0.0 </span><span class="cov5" title="178">{
                                result = diffM / ind.currentTrueRange
                        }</span> <span class="cov6" title="322">else {
                                result = 0
                        }</span>

                        // increment the number of results this indicator can be expected to return
                        <span class="cov6" title="500">ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov1" title="2">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        // update the maximum result value
                        <span class="cov6" title="500">if result &gt; ind.maxValue </span><span class="cov2" title="8">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov6" title="500">if result &lt; ind.minValue </span><span class="cov1" title="2">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov6" title="500">ind.valueAvailableAction(result, streamBarIndex)</span>
                }
        } <span class="cov9" title="12964">else {
                if ind.periodCounter &gt; 0 </span><span class="cov9" title="12832">{
                        if ind.periodCounter &lt; ind.timePeriod </span><span class="cov7" title="1136">{
                                if (diffM &gt; 0) &amp;&amp; (diffP &lt; diffM) </span><span class="cov4" title="32">{
                                        ind.previousMinusDM += diffM
                                }</span>
                                <span class="cov7" title="1136">ind.previousTrueRange += ind.currentTrueRange</span>
                        } <span class="cov9" title="11696">else {
                                var result float64
                                ind.previousTrueRange = ind.previousTrueRange - (ind.previousTrueRange / float64(ind.timePeriod)) + ind.currentTrueRange
                                if (diffM &gt; 0) &amp;&amp; (diffP &lt; diffM) </span><span class="cov7" title="1048">{
                                        ind.previousMinusDM = ind.previousMinusDM - (ind.previousMinusDM / float64(ind.timePeriod)) + diffM
                                }</span> <span class="cov9" title="10648">else {
                                        ind.previousMinusDM = ind.previousMinusDM - (ind.previousMinusDM / float64(ind.timePeriod))
                                }</span>

                                <span class="cov9" title="11696">if ind.previousTrueRange != 0.0 </span><span class="cov9" title="11696">{
                                        result = float64(100.0) * ind.previousMinusDM / ind.previousTrueRange
                                }</span> <span class="cov0" title="0">else {
                                        result = 0.0
                                }</span>

                                // increment the number of results this indicator can be expected to return
                                <span class="cov9" title="11696">ind.dataLength += 1

                                if ind.validFromBar == -1 </span><span class="cov5" title="124">{
                                        // set the streamBarIndex from which this indicator returns valid results
                                        ind.validFromBar = streamBarIndex
                                }</span>

                                // update the maximum result value
                                <span class="cov9" title="11696">if result &gt; ind.maxValue </span><span class="cov6" title="432">{
                                        ind.maxValue = result
                                }</span>

                                // update the minimum result value
                                <span class="cov9" title="11696">if result &lt; ind.minValue </span><span class="cov6" title="212">{
                                        ind.minValue = result
                                }</span>

                                // notify of a new result value though the value available action
                                <span class="cov9" title="11696">ind.valueAvailableAction(result, streamBarIndex)</span>
                        }
                }
        }

        <span class="cov9" title="13466">ind.previousHigh = high
        ind.previousLow = low</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Minus Directional Movement Indicator (MinusDm), no storage, for use in other indicators
type MinusDmWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        previousHigh         float64
        previousLow          float64
        previousMinusDm      float64
        timePeriod           int
}

// NewMinusDmWithoutStorage creates a Minus Directional Movement Indicator (MinusDm) without storage
func NewMinusDmWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *MinusDmWithoutStorage, err error) <span class="cov5" title="46">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov5" title="46">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov5" title="46">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov5" title="46">lookback := 1
        if timePeriod &gt; 1 </span><span class="cov4" title="22">{
                lookback = timePeriod - 1
        }</span>
        <span class="cov5" title="46">ind := MinusDmWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        -1,
                previousMinusDm:      0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Minus Directional Movement Indicator (MinusDm)
type MinusDm struct {
        *MinusDmWithoutStorage

        // public variables
        Data []float64
}

// NewMinusDm creates a Minus Directional Movement Indicator (MinusDm) for online usage
func NewMinusDm(timePeriod int) (indicator *MinusDm, err error) <span class="cov4" title="24">{
        ind := MinusDm{}
        ind.MinusDmWithoutStorage, err = NewMinusDmWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1694">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="24">return &amp;ind, err</span>
}

// NewDefaultMinusDm creates a Minus Directional Movement Indicator (MinusDm) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultMinusDm() (indicator *MinusDm, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewMinusDm(timePeriod)
}</span>

// NewMinusDmWithSrcLen creates a Minus Directional Movement Indicator (MinusDm) for offline usage
func NewMinusDmWithSrcLen(sourceLength int, timePeriod int) (indicator *MinusDm, err error) <span class="cov0" title="0">{
        ind, err := NewMinusDm(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultMinusDmWithSrcLen creates a Minus Directional Movement Indicator (MinusDm) for offline usage with default parameters
func NewDefaultMinusDmWithSrcLen(sourceLength int) (indicator *MinusDm, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMinusDm()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewMinusDmForStream creates a Minus Directional Movement Indicator (MinusDm) for online usage with a source data stream
func NewMinusDmForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *MinusDm, err error) <span class="cov0" title="0">{
        ind, err := NewMinusDm(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMinusDmForStream creates a Minus Directional Movement Indicator (MinusDm) for online usage with a source data stream
func NewDefaultMinusDmForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *MinusDm, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMinusDm()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewMinusDmForStreamWithSrcLen creates a Minus Directional Movement Indicator (MinusDm) for offline usage with a source data stream
func NewMinusDmForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *MinusDm, err error) <span class="cov0" title="0">{
        ind, err := NewMinusDmWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMinusDmForStreamWithSrcLen creates a Minus Directional Movement Indicator (MinusDm) for offline usage with a source data stream
func NewDefaultMinusDmForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *MinusDm, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMinusDmWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *MinusDmWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1947">{
        ind.periodCounter += 1
        high := tickData.H()
        low := tickData.L()
        diffP := high - ind.previousHigh
        diffM := ind.previousLow - low

        if ind.lookbackPeriod == 1 </span><span class="cov8" title="532">{
                if ind.periodCounter &gt; 0 </span><span class="cov8" title="513">{

                        var result float64
                        if (diffM &gt; 0) &amp;&amp; (diffP &lt; diffM) </span><span class="cov7" title="178">{
                                result = diffM
                        }</span> <span class="cov7" title="335">else {
                                result = 0
                        }</span>

                        // increment the number of results this indicator can be expected to return
                        <span class="cov8" title="513">ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov4" title="15">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        // update the maximum result value
                        <span class="cov8" title="513">if result &gt; ind.maxValue </span><span class="cov3" title="12">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov8" title="513">if result &lt; ind.minValue </span><span class="cov4" title="15">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov8" title="513">ind.valueAvailableAction(result, streamBarIndex)</span>
                }
        } <span class="cov9" title="1415">else {
                if ind.periodCounter &gt; 0 </span><span class="cov9" title="1398">{
                        if ind.periodCounter &lt; ind.timePeriod </span><span class="cov7" title="217">{
                                if (diffM &gt; 0) &amp;&amp; (diffP &lt; diffM) </span><span class="cov3" title="8">{
                                        ind.previousMinusDm += diffM
                                }</span>

                                <span class="cov7" title="217">if ind.periodCounter == ind.timePeriod-1 </span><span class="cov4" title="13">{

                                        result := ind.previousMinusDm

                                        // increment the number of results this indicator can be expected to return
                                        ind.dataLength += 1

                                        if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                                                // set the streamBarIndex from which this indicator returns valid results
                                                ind.validFromBar = streamBarIndex
                                        }</span>

                                        // update the maximum result value
                                        <span class="cov4" title="13">if result &gt; ind.maxValue </span><span class="cov1" title="2">{
                                                ind.maxValue = result
                                        }</span>

                                        // update the minimum result value
                                        <span class="cov4" title="13">if result &lt; ind.minValue </span><span class="cov4" title="13">{
                                                ind.minValue = result
                                        }</span>

                                        // notify of a new result value though the value available action
                                        <span class="cov4" title="13">ind.valueAvailableAction(result, streamBarIndex)</span>

                                }
                        } <span class="cov9" title="1181">else {
                                var result float64
                                if (diffM &gt; 0) &amp;&amp; (diffP &lt; diffM) </span><span class="cov7" title="198">{
                                        result = ind.previousMinusDm - (ind.previousMinusDm / float64(ind.timePeriod)) + diffM
                                }</span> <span class="cov9" title="983">else {
                                        result = ind.previousMinusDm - (ind.previousMinusDm / float64(ind.timePeriod))
                                }</span>

                                // increment the number of results this indicator can be expected to return
                                <span class="cov9" title="1181">ind.dataLength += 1

                                if ind.validFromBar == -1 </span><span class="cov0" title="0">{
                                        // set the streamBarIndex from which this indicator returns valid results
                                        ind.validFromBar = streamBarIndex
                                }</span>

                                // update the maximum result value
                                <span class="cov9" title="1181">if result &gt; ind.maxValue </span><span class="cov5" title="50">{
                                        ind.maxValue = result
                                }</span>

                                // update the minimum result value
                                <span class="cov9" title="1181">if result &lt; ind.minValue </span><span class="cov3" title="12">{
                                        ind.minValue = result
                                }</span>

                                // notify of a new result value though the value available action
                                <span class="cov9" title="1181">ind.valueAvailableAction(result, streamBarIndex)

                                ind.previousMinusDm = result</span>
                        }
                }
        }

        <span class="cov10" title="1947">ind.previousHigh = high
        ind.previousLow = low</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Momentum Indicator (Mom), no storage, for use in other indicators
type MomWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        periodHistory        *list.List
        timePeriod           int
}

// NewMomWithoutStorage creates a Momentum Indicator (Mom) without storage
func NewMomWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *MomWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := MomWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod * -1),
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, err</span>
}

// A Momentum Indicator (Mom)
type Mom struct {
        *MomWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewMom creates a Momentum (Mom) for online usage
func NewMom(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Mom, err error) <span class="cov4" title="22">{
        ind := Mom{selectData: selectData}
        ind.MomWithoutStorage, err = NewMomWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov0" title="0">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">ind.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1242">{
                ind.Data = append(ind.Data, dataItem)
        }</span>
        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultMom creates a Momentum (Mom) for online usage with default parameters
//        - timePeriod: 10
//  - selectData: useClosePrice
func NewDefaultMom() (indicator *Mom, err error) <span class="cov0" title="0">{
        timePeriod := 10
        selectData := gotrade.UseClosePrice
        return NewMom(timePeriod, selectData)
}</span>

// NewMomWithSrcLen creates a Momentum (Mom) for offline usage
func NewMomWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Mom, err error) <span class="cov0" title="0">{
        ind, err := NewMom(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultMomWithSrcLen creates a Momentum (Mom) for offline usage with default parameters
func NewDefaultMomWithSrcLen(sourceLength int) (indicator *Mom, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMom()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewMomForStream creates a Momentum (Mom) for online usage with a source data stream
func NewMomForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Mom, err error) <span class="cov0" title="0">{
        newMom, err := NewMom(timePeriod, selectData)
        priceStream.AddTickSubscription(newMom)
        return newMom, err
}</span>

// NewDefaultMomForStream creates a Momentum (Mom) for online usage with a source data stream
func NewDefaultMomForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Mom, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMom()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewMomForStreamWithSrcLen creates a Momentum (Mom) for offline usage with a source data stream
func NewMomForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Mom, err error) <span class="cov0" title="0">{
        ind, err := NewMomWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultMomForStreamWithSrcLen creates a Momentum (Mom) for offline usage with a source data stream
func NewDefaultMomForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Mom, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultMomWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Mom) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1367">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *MomWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1367">{
        ind.periodCounter += 1
        ind.periodHistory.PushBack(tickData)

        if ind.periodCounter &gt; 0 </span><span class="cov9" title="1242">{

                // Mom = price - previousPrice
                previousPrice := ind.periodHistory.Front().Value.(float64)

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>
                <span class="cov9" title="1242">var result float64 = tickData - previousPrice

                // update the maximum result value
                if result &gt; ind.maxValue </span><span class="cov5" title="41">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="1242">if result &lt; ind.minValue </span><span class="cov6" title="83">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1242">ind.valueAvailableAction(result, streamBarIndex)</span>
        }

        <span class="cov10" title="1367">if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="1242">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package indicators

import (
        "github.com/thetruetrade/gotrade"
)

// An On Balance Volume Indicator (Obv), no storage, for use in other indicators
type ObvWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodCounter        int
        previousObv          float64
        previousClose        float64
        valueAvailableAction ValueAvailableActionFloat
}

// NewObvWithoutStorage creates an On Balance Volume Indicator (Obv) without storage
func NewObvWithoutStorage(valueAvailableAction ValueAvailableActionFloat) (indicator *ObvWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        <span class="cov4" title="22">lookback := 0
        ind := ObvWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        -1,
                previousObv:          0.0,
                previousClose:        0.0,
                valueAvailableAction: valueAvailableAction,
        }

        return &amp;ind, nil</span>
}

// A On Balance Volume Indicator (Obv)
type Obv struct {
        *ObvWithoutStorage

        // public variables
        Data []float64
}

// NewObv creates an On Balance Volume Indicator (Obv) for online usage
func NewObv() (indicator *Obv, err error) <span class="cov4" title="22">{
        ind := Obv{}
        ind.ObvWithoutStorage, err = NewObvWithoutStorage(func(dataItem float64, streamBarIndex int) </span><span class="cov10" title="1311">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewObvWithSrcLen creates an On Balance Volume (Obv) for offline usage
func NewObvWithSrcLen(sourceLength int) (indicator *Obv, err error) <span class="cov0" title="0">{
        ind, err := NewObv()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewObvForStream creates an On Balance Volume (Obv) for online usage with a source data stream
func NewObvForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Obv, err error) <span class="cov0" title="0">{
        ind, err := NewObv()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewObvForStreamWithSrcLen creates an On Balance Volume (Obv) for offline usage with a source data stream
func NewObvForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Obv, err error) <span class="cov0" title="0">{
        ind, err := NewObvWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *ObvWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1311">{
        ind.periodCounter += 1

        if ind.periodCounter &lt;= 0 </span><span class="cov4" title="13">{
                ind.previousObv = tickData.V()
                ind.previousClose = tickData.C()

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                <span class="cov4" title="13">result := ind.previousObv

                // update the maximum result value
                if result &gt; ind.maxValue </span><span class="cov1" title="2">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov4" title="13">if result &lt; ind.minValue </span><span class="cov4" title="13">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov4" title="13">ind.valueAvailableAction(result, streamBarIndex)</span>
        }

        <span class="cov10" title="1311">if ind.periodCounter &gt; 0 </span><span class="cov9" title="1298">{
                closePrice := tickData.C()
                if closePrice &gt; ind.previousClose </span><span class="cov8" title="571">{
                        ind.previousObv += tickData.V()
                }</span> <span class="cov9" title="727">else if closePrice &lt; ind.previousClose </span><span class="cov7" title="256">{
                        ind.previousObv -= tickData.V()
                }</span>

                // increment the number of results this indicator can be expected to return
                <span class="cov9" title="1298">ind.dataLength += 1

                result := ind.previousObv

                // update the maximum result value
                if result &gt; ind.maxValue </span><span class="cov6" title="64">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="1298">if result &lt; ind.minValue </span><span class="cov5" title="38">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1298">ind.valueAvailableAction(result, streamBarIndex)
                ind.previousClose = tickData.C()</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Plus Directional Indicator (PlusDi), no storage, for use in other indicators
type PlusDiWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        previousHigh         float64
        previousLow          float64
        previousPlusDM       float64
        previousTrueRange    float64
        currentTrueRange     float64
        trueRange            *TrueRange
        timePeriod           int
}

// NewPlusDiWithoutStorage creates a Plus Directional Indicator (PlusDi) without storage
func NewPlusDiWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *PlusDiWithoutStorage, err error) <span class="cov6" title="240">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov6" title="240">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov6" title="240">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov6" title="240">lookback := 1
        if timePeriod &gt; 1 </span><span class="cov6" title="238">{
                lookback = timePeriod
        }</span>
        <span class="cov6" title="240">ind := PlusDiWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        -1,
                previousPlusDM:       0.0,
                previousTrueRange:    0.0,
                currentTrueRange:     0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.trueRange, err = NewTrueRange()

        ind.trueRange.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov10" title="13832">{
                ind.currentTrueRange = dataItem
        }</span>

        <span class="cov6" title="240">return &amp;ind, nil</span>
}

// A Plus Directional Indicator (PlusDi)
type PlusDi struct {
        *PlusDiWithoutStorage

        // public variables
        Data []float64
}

// NewPlusDi creates a Plus Directional Indicator (PlusDi) for online usage
func NewPlusDi(timePeriod int) (indicator *PlusDi, err error) <span class="cov6" title="240">{
        ind := PlusDi{}
        ind.PlusDiWithoutStorage, err = NewPlusDiWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov8" title="1685">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov6" title="240">return &amp;ind, err</span>
}

// NewDefaultPlusDi creates a Plus Directional Indicator (PlusDi) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultPlusDi() (indicator *PlusDi, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewPlusDi(timePeriod)
}</span>

// NewPlusDiWithSrcLen creates a Plus Directional Indicator (PlusDi) for offline usage
func NewPlusDiWithSrcLen(sourceLength int, timePeriod int) (indicator *PlusDi, err error) <span class="cov0" title="0">{
        ind, err := NewPlusDi(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultPlusDiWithSrcLen creates a Plus Directional Indicator (PlusDi) for offline usage with default parameters
func NewDefaultPlusDiWithSrcLen(sourceLength int) (indicator *PlusDi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultPlusDi()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewPlusDiForStream creates a Plus Directional Indicator (PlusDi) for online usage with a source data stream
func NewPlusDiForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *PlusDi, err error) <span class="cov0" title="0">{
        ind, err := NewPlusDi(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultPlusDiForStream creates a Plus Directional Indicator (PlusDi) for online usage with a source data stream
func NewDefaultPlusDiForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *PlusDi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultPlusDi()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewPlusDiForStreamWithSrcLen creates a Plus Directional Indicator (PlusDi) for offline usage with a source data stream
func NewPlusDiForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *PlusDi, err error) <span class="cov0" title="0">{
        ind, err := NewPlusDiWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultPlusDiForStreamWithSrcLen creates a Plus Directional Indicator (PlusDi) for offline usage with a source data stream
func NewDefaultPlusDiForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *PlusDi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultPlusDiWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *PlusDiWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov9" title="13466">{

        // forward to the true range indicator first using previous data
        ind.trueRange.ReceiveDOHLCVTick(tickData, streamBarIndex)

        ind.periodCounter += 1
        high := tickData.H()
        low := tickData.L()
        diffP := high - ind.previousHigh
        diffM := ind.previousLow - low

        if ind.lookbackPeriod == 1 </span><span class="cov6" title="502">{
                if ind.periodCounter &gt; 0 </span><span class="cov6" title="500">{

                        // forward to the true range indicator first using previous data
                        ind.trueRange.ReceiveDOHLCVTick(tickData, streamBarIndex)

                        var result float64
                        if (diffP &gt; 0) &amp;&amp; (diffP &gt; diffM) &amp;&amp; ind.currentTrueRange != 0.0 </span><span class="cov6" title="252">{
                                result = diffP / ind.currentTrueRange
                        }</span> <span class="cov6" title="248">else {
                                result = 0
                        }</span>

                        // increment the number of results this indicator can be expected to return
                        <span class="cov6" title="500">ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov1" title="2">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        <span class="cov6" title="500">if result &gt; ind.maxValue </span><span class="cov3" title="14">{
                                // update the maximum result value
                                ind.maxValue = result
                        }</span>

                        <span class="cov6" title="500">if result &lt; ind.minValue </span><span class="cov2" title="8">{
                                // update the minimum result value
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov6" title="500">ind.valueAvailableAction(result, streamBarIndex)</span>
                }
        } <span class="cov9" title="12964">else {
                if ind.periodCounter &gt; 0 </span><span class="cov9" title="12832">{
                        if ind.periodCounter &lt; ind.timePeriod </span><span class="cov7" title="1136">{
                                if (diffP &gt; 0) &amp;&amp; (diffP &gt; diffM) </span><span class="cov7" title="1088">{
                                        ind.previousPlusDM += diffP
                                }</span>
                                <span class="cov7" title="1136">ind.previousTrueRange += ind.currentTrueRange</span>
                        } <span class="cov9" title="11696">else {
                                var result float64
                                ind.previousTrueRange = ind.previousTrueRange - (ind.previousTrueRange / float64(ind.timePeriod)) + ind.currentTrueRange
                                if (diffP &gt; 0) &amp;&amp; (diffP &gt; diffM) </span><span class="cov8" title="4220">{
                                        ind.previousPlusDM = ind.previousPlusDM - (ind.previousPlusDM / float64(ind.timePeriod)) + diffP
                                }</span> <span class="cov9" title="7476">else {
                                        ind.previousPlusDM = ind.previousPlusDM - (ind.previousPlusDM / float64(ind.timePeriod))
                                }</span>

                                <span class="cov9" title="11696">if ind.previousTrueRange != 0.0 </span><span class="cov9" title="11696">{
                                        result = float64(100.0) * ind.previousPlusDM / ind.previousTrueRange
                                }</span> <span class="cov0" title="0">else {
                                        result = 0.0
                                }</span>

                                // increment the number of results this indicator can be expected to return
                                <span class="cov9" title="11696">ind.dataLength += 1

                                if ind.validFromBar == -1 </span><span class="cov5" title="124">{
                                        // set the streamBarIndex from which this indicator returns valid results
                                        ind.validFromBar = streamBarIndex
                                }</span>

                                // update the maximum result value
                                <span class="cov9" title="11696">if result &gt; ind.maxValue </span><span class="cov5" title="188">{
                                        ind.maxValue = result
                                }</span>

                                // update the minimum result value
                                <span class="cov9" title="11696">if result &lt; ind.minValue </span><span class="cov8" title="2794">{
                                        ind.minValue = result
                                }</span>

                                // notify of a new result value though the value available action
                                <span class="cov9" title="11696">ind.valueAvailableAction(result, streamBarIndex)</span>
                        }
                }
        }

        <span class="cov9" title="13466">ind.previousHigh = high
        ind.previousLow = low</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Plus Directional Movement Indicator (PlusDm), no storage, for use in other indicators
type PlusDmWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        previousHigh         float64
        previousLow          float64
        previousPlusDm       float64
        timePeriod           int
}

// NewPlusDmWithoutStorage creates a Plus Directional Movement Indicator (PlusDm) without storage
func NewPlusDmWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *PlusDmWithoutStorage, err error) <span class="cov4" title="24">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov4" title="24">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="24">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="24">lookback := 1
        if timePeriod &gt; 1 </span><span class="cov4" title="22">{
                lookback = timePeriod - 1
        }</span>
        <span class="cov4" title="24">newPlusDm := PlusDmWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        -1,
                previousPlusDm:       0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;newPlusDm, nil</span>
}

// A Plus Directional Movement Indicator (PlusDm)
type PlusDm struct {
        *PlusDmWithoutStorage

        // public variables
        Data []float64
}

// NewPlusDm creates a Plus Directional Movement Indicator (PlusDm) for online usage
func NewPlusDm(timePeriod int) (indicator *PlusDm, err error) <span class="cov4" title="24">{
        ind := PlusDm{}
        ind.PlusDmWithoutStorage, err = NewPlusDmWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1694">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="24">return &amp;ind, err</span>
}

// NewDefaultPlusDm creates a Plus Directional Movement Indicator (PlusDm) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultPlusDm() (indicator *PlusDm, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewPlusDm(timePeriod)
}</span>

// NewPlusDmWithSrcLen creates a Plus Directional Movement Indicator (PlusDm) for offline usage
func NewPlusDmWithSrcLen(sourceLength int, timePeriod int) (indicator *PlusDm, err error) <span class="cov0" title="0">{
        ind, err := NewPlusDm(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultPlusDmWithSrcLen creates a Plus Directional Movement Indicator (PlusDm) for offline usage with default parameters
func NewDefaultPlusDmWithSrcLen(sourceLength int) (indicator *PlusDm, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultPlusDm()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewPlusDmForStream creates a Plus Directional Movement Indicator (PlusDm) for online usage with a source data stream
func NewPlusDmForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *PlusDm, err error) <span class="cov0" title="0">{
        ind, err := NewPlusDm(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultPlusDmForStream creates a Plus Directional Movement Indicator (PlusDm) for online usage with a source data stream
func NewDefaultPlusDmForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *PlusDm, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultPlusDm()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewPlusDmForStreamWithSrcLen creates a Plus Directional Movement Indicator (PlusDm) for offline usage with a source data stream
func NewPlusDmForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *PlusDm, err error) <span class="cov0" title="0">{
        ind, err := NewPlusDmWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultPlusDmForStreamWithSrcLen creates a Plus Directional Movement Indicator (PlusDm) for offline usage with a source data stream
func NewDefaultPlusDmForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *PlusDm, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultPlusDmWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *PlusDmWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1917">{
        ind.periodCounter += 1
        high := tickData.H()
        low := tickData.L()
        diffP := high - ind.previousHigh
        diffM := ind.previousLow - low

        if ind.lookbackPeriod == 1 </span><span class="cov8" title="502">{
                if ind.periodCounter &gt; 0 </span><span class="cov8" title="500">{

                        var result float64
                        if (diffP &gt; 0) &amp;&amp; (diffP &gt; diffM) </span><span class="cov7" title="252">{
                                result = diffP
                        }</span> <span class="cov7" title="248">else {
                                result = 0
                        }</span>

                        // increment the number of results this indicator can be expected to return
                        <span class="cov8" title="500">ind.dataLength += 1

                        if ind.validFromBar == -1 </span><span class="cov1" title="2">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        // update the maximum result value
                        <span class="cov8" title="500">if result &gt; ind.maxValue </span><span class="cov4" title="18">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov8" title="500">if result &lt; ind.minValue </span><span class="cov3" title="8">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov8" title="500">ind.valueAvailableAction(result, streamBarIndex)</span>
                }
        } <span class="cov9" title="1415">else {
                if ind.periodCounter &gt; 0 </span><span class="cov9" title="1398">{
                        if ind.periodCounter &lt; ind.timePeriod </span><span class="cov7" title="217">{
                                if (diffP &gt; 0) &amp;&amp; (diffP &gt; diffM) </span><span class="cov7" title="205">{
                                        ind.previousPlusDm += diffP
                                }</span>

                                <span class="cov7" title="217">if ind.periodCounter == ind.timePeriod-1 </span><span class="cov4" title="13">{

                                        result := ind.previousPlusDm

                                        // increment the number of results this indicator can be expected to return
                                        ind.dataLength += 1

                                        if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                                                // set the streamBarIndex from which this indicator returns valid results
                                                ind.validFromBar = streamBarIndex
                                        }</span>

                                        // update the maximum result value
                                        <span class="cov4" title="13">if result &gt; ind.maxValue </span><span class="cov4" title="13">{
                                                ind.maxValue = result
                                        }</span>

                                        // update the minimum result value
                                        <span class="cov4" title="13">if result &lt; ind.minValue </span><span class="cov4" title="13">{
                                                ind.minValue = result
                                        }</span>

                                        // notify of a new result value though the value available action
                                        <span class="cov4" title="13">ind.valueAvailableAction(result, streamBarIndex)</span>

                                }
                        } <span class="cov9" title="1181">else {
                                var result float64
                                if (diffP &gt; 0) &amp;&amp; (diffP &gt; diffM) </span><span class="cov8" title="448">{
                                        result = ind.previousPlusDm - (ind.previousPlusDm / float64(ind.timePeriod)) + diffP
                                }</span> <span class="cov8" title="733">else {
                                        result = ind.previousPlusDm - (ind.previousPlusDm / float64(ind.timePeriod))
                                }</span>

                                // increment the number of results this indicator can be expected to return
                                <span class="cov9" title="1181">ind.dataLength += 1

                                if ind.validFromBar == -1 </span><span class="cov0" title="0">{
                                        // set the streamBarIndex from which this indicator returns valid results
                                        ind.validFromBar = streamBarIndex
                                }</span>

                                // update the maximum result value
                                <span class="cov9" title="1181">if result &gt; ind.maxValue </span><span class="cov4" title="24">{
                                        ind.maxValue = result
                                }</span>

                                // update the minimum result value
                                <span class="cov9" title="1181">if result &lt; ind.minValue </span><span class="cov7" title="222">{
                                        ind.minValue = result
                                }</span>

                                // notify of a new result value though the value available action
                                <span class="cov9" title="1181">ind.valueAvailableAction(result, streamBarIndex)

                                ind.previousPlusDm = result</span>
                        }
                }
        }

        <span class="cov10" title="1917">ind.previousHigh = high
        ind.previousLow = low</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Rate of Change Indicator (Roc), no storage, for use in other indicators
type RocWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        periodHistory        *list.List
        timePeriod           int
}

// NewRocWithoutStorage creates a Rate of Change Indicator (Roc) without storage
func NewRocWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *RocWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov4" title="22">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := RocWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod * -1),
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Rate of Change Indicator (Roc)
type Roc struct {
        *RocWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewRoc creates a Rate of Change Indicator (Roc) for online usage
func NewRoc(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Roc, err error) <span class="cov4" title="22">{
        ind := Roc{selectData: selectData}
        ind.RocWithoutStorage, err = NewRocWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov0" title="0">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">ind.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1242">{
                ind.Data = append(ind.Data, dataItem)
        }</span>
        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultRoc creates a Rate of Change Indicator (Roc) for online usage with default parameters
//        - timePeriod: 10
func NewDefaultRoc() (indicator *Roc, err error) <span class="cov0" title="0">{
        timePeriod := 10
        return NewRoc(timePeriod, gotrade.UseClosePrice)
}</span>

// NewRocWithSrcLen creates a Rate of Change Indicator (Roc) for offline usage
func NewRocWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Roc, err error) <span class="cov0" title="0">{
        ind, err := NewRoc(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultRocWithSrcLen creates a Rate of Change Indicator (Roc) for offline usage with default parameters
func NewDefaultRocWithSrcLen(sourceLength int) (indicator *Roc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRoc()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewRocForStream creates a Rate of Change Indicator (Roc) for online usage with a source data stream
func NewRocForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Roc, err error) <span class="cov0" title="0">{
        ind, err := NewRoc(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRocForStream creates a Rate of Change Indicator (Roc) for online usage with a source data stream
func NewDefaultRocForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Roc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRoc()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewRocForStreamWithSrcLen creates a Rate of Change Indicator (Roc) for offline usage with a source data stream
func NewRocForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Roc, err error) <span class="cov0" title="0">{
        ind, err := NewRocWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRocForStreamWithSrcLen creates a Rate of Change Indicator (Roc) for offline usage with a source data stream
func NewDefaultRocForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Roc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Roc) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1367">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *RocWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1367">{
        ind.periodCounter += 1
        ind.periodHistory.PushBack(tickData)

        if ind.periodCounter &gt; 0 </span><span class="cov9" title="1242">{

                //    Roc = (price/previousPrice - 1) * 100
                previousPrice := ind.periodHistory.Front().Value.(float64)

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>
                <span class="cov9" title="1242">var result float64
                if previousPrice != 0 </span><span class="cov9" title="1242">{
                        result = 100.0 * ((tickData / previousPrice) - 1)
                }</span> <span class="cov0" title="0">else {
                        result = 0.0
                }</span>

                // update the maximum result value
                <span class="cov9" title="1242">if result &gt; ind.maxValue </span><span class="cov5" title="37">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="1242">if result &lt; ind.minValue </span><span class="cov7" title="139">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1242">ind.valueAvailableAction(result, streamBarIndex)</span>
        }

        <span class="cov10" title="1367">if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="1242">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Rate of Change Percentage Indicator (RocP), no storage, for use in other indicators
type RocPWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        periodHistory        *list.List
        timePeriod           int
}

// NewRocPWithoutStorage creates a Rate of Change Percentage Indicator (RocP) without storage
func NewRocPWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *RocPWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov4" title="22">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := RocPWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod * -1),
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, err</span>
}

// A Rate of Change Percentage Indicator (RocP)
type RocP struct {
        *RocPWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewRocP creates a Rate of Change Percentage Indicator (RocP) for online usage
func NewRocP(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocP, err error) <span class="cov4" title="22">{
        ind := RocP{selectData: selectData}
        ind.RocPWithoutStorage, err = NewRocPWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov0" title="0">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">ind.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1242">{
                ind.Data = append(ind.Data, dataItem)
        }</span>
        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultRocP creates a Rate of Change Percentage Indicator (RocP) for online usage with default parameters
//        - timePeriod: 10
func NewDefaultRocP() (indicator *RocP, err error) <span class="cov0" title="0">{
        timePeriod := 10
        return NewRocP(timePeriod, gotrade.UseClosePrice)
}</span>

// NewRocPWithSrcLen creates a Rate of Change Percentage Indicator (RocP) for offline usage
func NewRocPWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocP, err error) <span class="cov0" title="0">{
        ind, err := NewRocP(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultRocPWithSrcLen creates a Rate of Change Percentage Indicator (RocP) for offline usage with default parameters
func NewDefaultRocPWithSrcLen(sourceLength int) (indicator *RocP, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocP()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewRocPForStream creates a Rate of Change Percentage Indicator (RocP) for online usage with a source data stream
func NewRocPForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocP, err error) <span class="cov0" title="0">{
        ind, err := NewRocP(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRocPForStream creates a Rate of Change Percentage Indicator (RocP) for online usage with a source data stream
func NewDefaultRocPForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *RocP, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocP()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewRocPForStreamWithSrcLen creates a Rate of Change Percentage Indicator (RocP) for offline usage with a source data stream
func NewRocPForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocP, err error) <span class="cov0" title="0">{
        ind, err := NewRocPWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRocPForStreamWithSrcLen creates a Rate of Change Percentage Indicator (RocP) for offline usage with a source data stream
func NewDefaultRocPForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *RocP, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocPWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *RocP) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1367">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *RocPWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1367">{
        ind.periodCounter += 1
        ind.periodHistory.PushBack(tickData)

        if ind.periodCounter &gt; 0 </span><span class="cov9" title="1242">{

                //    RocP = (price/previousPrice - 1) * 100
                previousPrice := ind.periodHistory.Front().Value.(float64)

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>
                <span class="cov9" title="1242">var result float64
                if previousPrice != 0 </span><span class="cov9" title="1242">{
                        result = (tickData - previousPrice) / previousPrice
                }</span> <span class="cov0" title="0">else {
                        result = 0.0
                }</span>

                // update the maximum result value
                <span class="cov9" title="1242">if result &gt; ind.maxValue </span><span class="cov5" title="37">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="1242">if result &lt; ind.minValue </span><span class="cov7" title="139">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1242">ind.valueAvailableAction(result, streamBarIndex)</span>
        }

        <span class="cov10" title="1367">if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="1242">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Rate of Change Ratio Indicator (RocR), no storage, for use in other indicators
type RocRWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        periodHistory        *list.List
        timePeriod           int
}

// NewRocRWithoutStorage creates a Rate of Change Ratio Indicator (RocR) without storage
func NewRocRWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *RocRWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov4" title="22">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := RocRWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod * -1),
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, err</span>
}

// A Rate of Change Ratio Indicator (RocR)
type RocR struct {
        *RocRWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewRocR creates a Rate of Change Ratio Indicator (RocR) for online usage
func NewRocR(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocR, err error) <span class="cov4" title="22">{
        ind := RocR{selectData: selectData}
        ind.RocRWithoutStorage, err = NewRocRWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov0" title="0">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">ind.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1242">{
                ind.Data = append(ind.Data, dataItem)
        }</span>
        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultRocR creates a Rate of Change Ratio Indicator (RocR) for online usage with default parameters
//        - timePeriod: 10
func NewDefaultRocR() (indicator *RocR, err error) <span class="cov0" title="0">{
        timePeriod := 10
        return NewRocR(timePeriod, gotrade.UseClosePrice)
}</span>

// NewRocRWithSrcLen creates a Rate of Change Ratio Indicator (RocR) for offline usage
func NewRocRWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocR, err error) <span class="cov0" title="0">{
        ind, err := NewRocR(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultRocRWithSrcLen creates a Rate of Change Ratio Indicator (RocR) for offline usage with default parameters
func NewDefaultRocRWithSrcLen(sourceLength int) (indicator *RocR, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocR()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewRocRForStream creates a Rate of Change Ratio Indicator (RocR) for online usage with a source data stream
func NewRocRForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocR, err error) <span class="cov0" title="0">{
        ind, err := NewRocR(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRocRForStream creates a Rate of Change Ratio Indicator (RocR) for online usage with a source data stream
func NewDefaultRocRForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *RocR, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocR()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewRocRForStreamWithSrcLen creates a Rate of Change Ratio Indicator (RocR) for offline usage with a source data stream
func NewRocRForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocR, err error) <span class="cov0" title="0">{
        ind, err := NewRocRWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRocRForStreamWithSrcLen creates a Rate of Change Ratio Indicator (RocR) for offline usage with a source data stream
func NewDefaultRocRForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *RocR, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocRWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *RocR) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1367">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *RocRWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1367">{
        ind.periodCounter += 1
        ind.periodHistory.PushBack(tickData)

        if ind.periodCounter &gt; 0 </span><span class="cov9" title="1242">{

                //    RocR = (price/previousPrice - 1) * 100
                previousPrice := ind.periodHistory.Front().Value.(float64)

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>
                <span class="cov9" title="1242">var result float64
                if previousPrice != 0 </span><span class="cov9" title="1242">{
                        result = (tickData / previousPrice)
                }</span> <span class="cov0" title="0">else {
                        result = 0.0
                }</span>

                // update the maximum result value
                <span class="cov9" title="1242">if result &gt; ind.maxValue </span><span class="cov5" title="41">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="1242">if result &lt; ind.minValue </span><span class="cov7" title="139">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1242">ind.valueAvailableAction(result, streamBarIndex)</span>
        }

        <span class="cov10" title="1367">if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="1242">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Rate of Change Ratio 100 Scale Indicator (RocR100), no storage, for use in other indicators
type RocR100WithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        periodHistory        *list.List
        timePeriod           int
}

// NewRocR100WithoutStorage creates a Rate of Change Ratio 100 Scale Indicator (RocR100) without storage
func NewRocR100WithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *RocR100WithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov4" title="22">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := RocR100WithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod * -1),
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, err</span>
}

// A Rate of Change Ratio Indicator (RocR)
type RocR100 struct {
        *RocR100WithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewRocR100 creates a Rate of Change Ratio 100 Scale Indicator (RocR100) for online usage
func NewRocR100(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocR100, err error) <span class="cov4" title="22">{
        newRocR100 := RocR100{selectData: selectData}
        newRocR100.RocR100WithoutStorage, err = NewRocR100WithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov0" title="0">{
                        newRocR100.Data = append(newRocR100.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">newRocR100.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1242">{
                newRocR100.Data = append(newRocR100.Data, dataItem)
        }</span>
        <span class="cov4" title="22">return &amp;newRocR100, err</span>
}

/// NewDefaultRocR100 creates a Rate of Change Ratio 100 Scale Indicator (RocR100) for online usage with default parameters
//        - timePeriod: 10
func NewDefaultRocR100() (indicator *RocR100, err error) <span class="cov0" title="0">{
        timePeriod := 10
        return NewRocR100(timePeriod, gotrade.UseClosePrice)
}</span>

// NewRocR100WithSrcLen creates a Rate of Change Ratio 100 Scale Indicator (RocR100) for offline usage
func NewRocR100WithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocR100, err error) <span class="cov0" title="0">{
        ind, err := NewRocR100(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultRocR100WithSrcLen creates a Rate of Change Ratio 100 Scale Indicator (RocR100) for offline usage with default parameters
func NewDefaultRocR100WithSrcLen(sourceLength int) (indicator *RocR100, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocR100()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewRocR100ForStream creates a Rate of Change Ratio 100 Scale Indicator (RocR100) for online usage with a source data stream
func NewRocR100ForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocR100, err error) <span class="cov0" title="0">{
        ind, err := NewRocR100(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRocR100ForStream creates a Rate of Change Ratio 100 Scale Indicator (RocR100) for online usage with a source data stream
func NewDefaultRocR100ForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *RocR100, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocR100()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewRocR100ForStreamWithSrcLen creates a Rate of Change Ratio 100 Scale Indicator (RocR100) for offline usage with a source data stream
func NewRocR100ForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *RocR100, err error) <span class="cov0" title="0">{
        ind, err := NewRocR100WithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRocR100ForStreamWithSrcLen creates a Rate of Change Ratio 100 Scale Indicator (RocR100) for offline usage with a source data stream
func NewDefaultRocR100ForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *RocR100, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRocR100WithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *RocR100) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1367">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *RocR100WithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1367">{
        ind.periodCounter += 1
        ind.periodHistory.PushBack(tickData)

        if ind.periodCounter &gt; 0 </span><span class="cov9" title="1242">{

                //    RocR100 = (price/previousPrice - 1) * 100
                previousPrice := ind.periodHistory.Front().Value.(float64)

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>
                <span class="cov9" title="1242">var result float64
                if previousPrice != 0 </span><span class="cov9" title="1242">{
                        result = (tickData / previousPrice) * 100.0
                }</span> <span class="cov0" title="0">else {
                        result = 0.0
                }</span>

                // update the maximum result value
                <span class="cov9" title="1242">if result &gt; ind.maxValue </span><span class="cov5" title="41">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="1242">if result &lt; ind.minValue </span><span class="cov7" title="139">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1242">ind.valueAvailableAction(result, streamBarIndex)</span>
        }

        <span class="cov10" title="1367">if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="1242">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Relative Strength Indicator (Rsi), no storage, for use in other indicators
type RsiWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        periodCounter        int
        previousClose        float64
        previousGain         float64
        previousLoss         float64
        timePeriod           int
}

// NewRsiWithoutStorage creates a Relative Strength Indicator (Rsi) without storage
func NewRsiWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *RsiWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod
        ind := RsiWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        (timePeriod * -1) - 1,
                previousClose:        0.0,
                previousGain:         0.0,
                previousLoss:         0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, err</span>
}

// A Relative Strength Indicator (Rsi)
type Rsi struct {
        *RsiWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewRsi creates a Relative Strength Indicator (Rsi) for online usage
func NewRsi(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Rsi, err error) <span class="cov4" title="22">{
        ind := Rsi{selectData: selectData}
        ind.RsiWithoutStorage, err = NewRsiWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov0" title="0">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">ind.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1234">{
                ind.Data = append(ind.Data, dataItem)
        }</span>
        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultRsi creates a Relative Strength Indicator (Rsi) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultRsi() (indicator *Rsi, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewRsi(timePeriod, gotrade.UseClosePrice)
}</span>

// NewRsiWithSrcLen creates a Relative Strength Indicator (Rsi) for offline usage
func NewRsiWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Rsi, err error) <span class="cov0" title="0">{
        ind, err := NewRsi(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultRsiWithSrcLen creates a Relative Strength Indicator (Rsi) for offline usage with default parameters
func NewDefaultRsiWithSrcLen(sourceLength int) (indicator *Rsi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRsi()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewRsiForStream creates a Relative Strength Indicator (Rsi) for online usage with a source data stream
func NewRsiForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Rsi, err error) <span class="cov0" title="0">{
        ind, err := NewRsi(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRsiForStream creates a Relative Strength Indicator (Rsi) for online usage with a source data stream
func NewDefaultRsiForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Rsi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRsi()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewRsiForStreamWithSrcLen creates a Relative Strength Indicator (Rsi) for offline usage with a source data stream
func NewRsiForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Rsi, err error) <span class="cov0" title="0">{
        ind, err := NewRsiWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultRsiForStreamWithSrcLen creates a Relative Strength Indicator (Rsi) for offline usage with a source data stream
func NewDefaultRsiForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Rsi, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultRsiWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Rsi) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1367">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *RsiWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1367">{
        ind.periodCounter += 1

        if ind.periodCounter &gt; ind.timePeriod*-1 </span><span class="cov9" title="1350">{

                if ind.periodCounter &lt;= 0 </span><span class="cov7" title="129">{

                        if tickData &gt; ind.previousClose </span><span class="cov6" title="111">{
                                ind.previousGain += (tickData - ind.previousClose)
                        }</span> <span class="cov4" title="18">else {
                                ind.previousLoss -= (tickData - ind.previousClose)
                        }</span>
                }

                <span class="cov9" title="1350">if ind.periodCounter == 0 </span><span class="cov4" title="13">{
                        ind.previousGain /= float64(ind.timePeriod)
                        ind.previousLoss /= float64(ind.timePeriod)

                        // increment the number of results this indicator can be expected to return
                        ind.dataLength += 1
                        if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                                // set the streamBarIndex from which this indicator returns valid results
                                ind.validFromBar = streamBarIndex
                        }</span>

                        <span class="cov4" title="13">var result float64
                        //    Rsi = 100 * (prevGain/(prevGain+prevLoss))
                        if ind.previousGain+ind.previousLoss == 0.0 </span><span class="cov0" title="0">{
                                result = 0.0
                        }</span> <span class="cov4" title="13">else {
                                result = 100.0 * (ind.previousGain / (ind.previousGain + ind.previousLoss))
                        }</span>

                        // update the maximum result value
                        <span class="cov4" title="13">if result &gt; ind.maxValue </span><span class="cov4" title="13">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov4" title="13">if result &lt; ind.minValue </span><span class="cov4" title="13">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov4" title="13">ind.valueAvailableAction(result, streamBarIndex)</span>
                }

                <span class="cov9" title="1350">if ind.periodCounter &gt; 0 </span><span class="cov9" title="1221">{
                        ind.previousGain *= float64(ind.timePeriod - 1)
                        ind.previousLoss *= float64(ind.timePeriod - 1)

                        if tickData &gt; ind.previousClose </span><span class="cov8" title="512">{
                                ind.previousGain += (tickData - ind.previousClose)
                        }</span> <span class="cov9" title="709">else {
                                ind.previousLoss -= (tickData - ind.previousClose)
                        }</span>

                        <span class="cov9" title="1221">ind.previousGain /= float64(ind.timePeriod)
                        ind.previousLoss /= float64(ind.timePeriod)

                        // increment the number of results this indicator can be expected to return
                        ind.dataLength += 1

                        var result float64
                        //    Rsi = 100 * (prevGain/(prevGain+prevLoss))
                        if ind.previousGain+ind.previousLoss == 0.0 </span><span class="cov0" title="0">{
                                result = 0.0
                        }</span> <span class="cov9" title="1221">else {
                                result = 100.0 * (ind.previousGain / (ind.previousGain + ind.previousLoss))
                        }</span>

                        // update the maximum result value
                        <span class="cov9" title="1221">if result &gt; ind.maxValue </span><span class="cov4" title="18">{
                                ind.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov9" title="1221">if result &lt; ind.minValue </span><span class="cov5" title="38">{
                                ind.minValue = result
                        }</span>

                        // notify of a new result value though the value available action
                        <span class="cov9" title="1221">ind.valueAvailableAction(result, streamBarIndex)</span>
                }
        }
        <span class="cov10" title="1367">ind.previousClose = tickData</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Stop and Reverse Indicator (Sar), no storage, for use in other indicators
type SarWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction  ValueAvailableActionFloat
        periodCounter         int
        isLong                bool
        extremePoint          float64
        accelerationFactor    float64
        acceleration          float64
        accelerationFactorMax float64
        previousSar           float64
        previousHigh          float64
        previousLow           float64
        minusDM               *MinusDmWithoutStorage
        hasInitialDirection   bool
}

func NewSarWithoutStorage(accelerationFactor float64, accelerationFactorMax float64, valueAvailableAction ValueAvailableActionFloat) (indicator *SarWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum accelerationFactor for this indicator is 0
        <span class="cov4" title="22">if accelerationFactor &lt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("accelerationFactor is less than the minimum (0)")
        }</span>

        // check the maximum accelerationFactor
        <span class="cov4" title="22">if accelerationFactor &gt; math.MaxFloat64 </span><span class="cov0" title="0">{
                return nil, errors.New("accelerationFactor is greater than the maximum float64 size")
        }</span>

        // the minimum accelerationFactorMax for this indicator is 0
        <span class="cov4" title="22">if accelerationFactorMax &lt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("accelerationFactorMax is less than the minimum (0)")
        }</span>

        // check the maximum accelerationFactorMax
        <span class="cov4" title="22">if accelerationFactorMax &gt; math.MaxFloat64 </span><span class="cov0" title="0">{
                return nil, errors.New("accelerationFactorMax is greater than the maximum float64 size")
        }</span>

        <span class="cov4" title="22">lookback := 1
        ind := SarWithoutStorage{
                baseIndicator:         newBaseIndicator(lookback),
                baseFloatBounds:       newBaseFloatBounds(),
                periodCounter:         -2,
                isLong:                false,
                hasInitialDirection:   false,
                accelerationFactor:    accelerationFactor,
                accelerationFactorMax: accelerationFactorMax,
                extremePoint:          0.0,
                previousSar:           0.0,
                previousHigh:          0.0,
                previousLow:           0.0,
                acceleration:          accelerationFactor,
                valueAvailableAction:  valueAvailableAction,
        }

        ind.minusDM, err = NewMinusDmWithoutStorage(1, func(dataItem float64, streamBarIndex int) </span><span class="cov4" title="13">{
                if dataItem &gt; 0 </span><span class="cov0" title="0">{
                        ind.isLong = false
                }</span> <span class="cov4" title="13">else {
                        ind.isLong = true
                }</span>
                <span class="cov4" title="13">ind.hasInitialDirection = true</span>
        })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// A Stop and Reverse Indicator (Sar)
type Sar struct {
        *SarWithoutStorage

        // public variables
        Data []float64
}

// NewSar creates a Stop and Reverse Indicator (Sar) for online usage
func NewSar(accelerationFactor float64, accelerationFactorMax float64) (indicator *Sar, err error) <span class="cov4" title="22">{
        ind := Sar{}
        ind.SarWithoutStorage, err = NewSarWithoutStorage(accelerationFactor, accelerationFactorMax, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1302">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultSar creates a Stop and Reverse Indicator (Sar) for online usage with default parameters
//        - accelerationFactor: 0.02
//  - accelerationFactorMax: 0.2
func NewDefaultSar() (indicator *Sar, err error) <span class="cov0" title="0">{
        accelerationFactor := 0.02
        accelerationFactorMax := 0.2
        return NewSar(accelerationFactor, accelerationFactorMax)
}</span>

// NewSarWithSrcLen creates a Stop and Reverse Indicator (Sar) for offline usage
func NewSarWithSrcLen(sourceLength int, accelerationFactor float64, accelerationFactorMax float64) (indicator *Sar, err error) <span class="cov0" title="0">{
        ind, err := NewSar(accelerationFactor, accelerationFactorMax)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultSarWithSrcLen creates a Stop and Reverse Indicator (Sar) for offline usage with default parameters
func NewDefaultSarWithSrcLen(sourceLength int) (indicator *Sar, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultSar()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewSarForStream creates a Stop and Reverse Indicator (Sar) for online usage with a source data stream
func NewSarForStream(priceStream gotrade.DOHLCVStreamSubscriber, accelerationFactor float64, accelerationFactorMax float64) (indicator *Sar, err error) <span class="cov0" title="0">{
        ind, err := NewSar(accelerationFactor, accelerationFactorMax)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultSarForStream creates a Stop and Reverse Indicator (Sar) for online usage with a source data stream
func NewDefaultSarForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Sar, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultSar()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewSarForStreamWithSrcLen creates a Stop and Reverse Indicator (Sar) for offline usage with a source data stream
func NewSarForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, accelerationFactor float64, accelerationFactorMax float64) (indicator *Sar, err error) <span class="cov0" title="0">{
        ind, err := NewSarWithSrcLen(sourceLength, accelerationFactor, accelerationFactorMax)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultSarForStreamWithSrcLen creates a Stop and Reverse Indicator (Sar) for offline usage with a source data stream
func NewDefaultSarForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Sar, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultSarWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *SarWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1319">{
        ind.periodCounter += 1
        if ind.hasInitialDirection == false </span><span class="cov5" title="30">{
                ind.minusDM.ReceiveDOHLCVTick(tickData, streamBarIndex)
        }</span>

        <span class="cov10" title="1319">if ind.hasInitialDirection == true </span><span class="cov9" title="1302">{
                if ind.periodCounter == 0 </span><span class="cov4" title="13">{
                        if ind.isLong </span><span class="cov4" title="13">{
                                ind.extremePoint = tickData.H()
                                ind.previousSar = ind.previousLow
                        }</span> <span class="cov0" title="0">else {
                                ind.extremePoint = tickData.L()
                                ind.previousSar = ind.previousHigh
                        }</span>

                        // this is a trick for the first iteration only,
                        // the high low of the first bar will be used as the sar for the
                        // second bar. According tyo TALib this is the closest to Wilders
                        // originla idea of having the first entry day use the previous
                        // extreme, except now that extreme is solely derived from the first
                        // bar, supposedly Meta stock uses the same method.
                        <span class="cov4" title="13">ind.previousHigh = tickData.H()
                        ind.previousLow = tickData.L()</span>
                }

                <span class="cov9" title="1302">if ind.periodCounter &gt;= 0 </span><span class="cov9" title="1302">{
                        var result float64 = 0.0
                        if ind.isLong </span><span class="cov9" title="852">{
                                if tickData.L() &lt;= ind.previousSar </span><span class="cov6" title="92">{
                                        // switch to short if the low penetrates the Sar value
                                        ind.isLong = false
                                        ind.previousSar = ind.extremePoint

                                        // make sure the overridden Sar is within yesterdays and todays range
                                        if ind.previousSar &lt; ind.previousHigh </span><span class="cov0" title="0">{
                                                ind.previousSar = ind.previousHigh
                                        }</span>
                                        <span class="cov6" title="92">if ind.previousSar &lt; tickData.H() </span><span class="cov0" title="0">{
                                                ind.previousSar = tickData.H()
                                        }</span>

                                        <span class="cov6" title="92">result = ind.previousSar

                                        // increment the number of results this indicator can be expected to return
                                        ind.dataLength += 1

                                        if ind.validFromBar == -1 </span><span class="cov0" title="0">{
                                                // set the streamBarIndex from which this indicator returns valid results
                                                ind.validFromBar = streamBarIndex
                                        }</span>

                                        // update the maximum result value
                                        <span class="cov6" title="92">if result &gt; ind.maxValue </span><span class="cov4" title="21">{
                                                ind.maxValue = result
                                        }</span>

                                        // update the minimum result value
                                        <span class="cov6" title="92">if result &lt; ind.minValue </span><span class="cov0" title="0">{
                                                ind.minValue = result
                                        }</span>

                                        // notify of a new result value though the value available action
                                        <span class="cov6" title="92">ind.valueAvailableAction(result, streamBarIndex)

                                        // adjust af and extremePoint
                                        ind.acceleration = ind.accelerationFactor
                                        ind.extremePoint = tickData.L()

                                        // calculate the new Sar
                                        var diff float64 = ind.extremePoint - ind.previousSar
                                        ind.previousSar = ind.previousSar + ind.acceleration*(diff)

                                        // make sure the overridden Sar is within yesterdays and todays range
                                        if ind.previousSar &lt; ind.previousHigh </span><span class="cov6" title="78">{
                                                ind.previousSar = ind.previousHigh
                                        }</span>
                                        <span class="cov6" title="92">if ind.previousSar &lt; tickData.H() </span><span class="cov0" title="0">{
                                                ind.previousSar = tickData.H()
                                        }</span>

                                } <span class="cov9" title="760">else {
                                        // no switch

                                        // just output the current Sar
                                        result = ind.previousSar

                                        // increment the number of results this indicator can be expected to return
                                        ind.dataLength += 1

                                        if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                                                // set the streamBarIndex from which this indicator returns valid results
                                                ind.validFromBar = streamBarIndex
                                        }</span>

                                        <span class="cov9" title="760">if result &gt; ind.maxValue </span><span class="cov7" title="165">{
                                                // update the maximum result value
                                                ind.maxValue = result
                                        }</span>

                                        // update the minimum result value
                                        <span class="cov9" title="760">if result &lt; ind.minValue </span><span class="cov4" title="13">{
                                                ind.minValue = result
                                        }</span>

                                        // notify of a new result value though the value available action
                                        <span class="cov9" title="760">ind.valueAvailableAction(result, streamBarIndex)

                                        if tickData.H() &gt; ind.extremePoint </span><span class="cov7" title="252">{
                                                // adjust af and extremePoint
                                                ind.extremePoint = tickData.H()
                                                ind.acceleration += ind.accelerationFactor
                                                if ind.acceleration &gt; ind.accelerationFactorMax </span><span class="cov6" title="55">{
                                                        ind.acceleration = ind.accelerationFactorMax
                                                }</span>
                                        }

                                        // calculate the new Sar
                                        <span class="cov9" title="760">var diff float64 = ind.extremePoint - ind.previousSar
                                        ind.previousSar = ind.previousSar + ind.acceleration*(diff)

                                        // make sure the overridden Sar is within yesterdays and todays range
                                        if ind.previousSar &gt; ind.previousLow </span><span class="cov4" title="13">{
                                                ind.previousSar = ind.previousLow
                                        }</span>
                                        <span class="cov9" title="760">if ind.previousSar &gt; tickData.L() </span><span class="cov2" title="4">{
                                                ind.previousSar = tickData.L()
                                        }</span>
                                }
                        } <span class="cov8" title="450">else {
                                // short
                                // switch to long if the high penetrates the Sar value
                                if tickData.H() &gt;= ind.previousSar </span><span class="cov6" title="92">{
                                        ind.isLong = true
                                        ind.previousSar = ind.extremePoint

                                        // make sure the overridden Sar is within yesterdays and todays range
                                        if ind.previousSar &gt; ind.previousLow </span><span class="cov0" title="0">{
                                                ind.previousSar = ind.previousLow
                                        }</span>
                                        <span class="cov6" title="92">if ind.previousSar &gt; tickData.L() </span><span class="cov0" title="0">{
                                                ind.previousSar = tickData.L()
                                        }</span>

                                        <span class="cov6" title="92">result = ind.previousSar

                                        // increment the number of results this indicator can be expected to return
                                        ind.dataLength += 1

                                        if ind.validFromBar == -1 </span><span class="cov0" title="0">{
                                                // set the streamBarIndex from which this indicator returns valid results
                                                ind.validFromBar = streamBarIndex
                                        }</span>

                                        <span class="cov6" title="92">if result &gt; ind.maxValue </span><span class="cov0" title="0">{
                                                // update the maximum result value
                                                ind.maxValue = result
                                        }</span>

                                        // update the minimum result value
                                        <span class="cov6" title="92">if result &lt; ind.minValue </span><span class="cov2" title="4">{
                                                ind.minValue = result
                                        }</span>

                                        // notify of a new result value though the value available action
                                        <span class="cov6" title="92">ind.valueAvailableAction(result, streamBarIndex)

                                        // adjust af and extremePoint
                                        ind.acceleration = ind.accelerationFactor
                                        ind.extremePoint = tickData.H()

                                        // calculate the new Sar
                                        var diff float64 = ind.extremePoint - ind.previousSar
                                        ind.previousSar = ind.previousSar + ind.acceleration*(diff)

                                        // make sure the overridden Sar is within yesterdays and todays range
                                        if ind.previousSar &gt; ind.previousLow </span><span class="cov5" title="42">{
                                                ind.previousSar = ind.previousLow
                                        }</span>
                                        <span class="cov6" title="92">if ind.previousSar &gt; tickData.L() </span><span class="cov0" title="0">{
                                                ind.previousSar = tickData.L()
                                        }</span>
                                } <span class="cov8" title="358">else {
                                        // no switch

                                        // just output the current Sar
                                        result = ind.previousSar

                                        // increment the number of results this indicator can be expected to return
                                        ind.dataLength += 1

                                        if ind.validFromBar == -1 </span><span class="cov0" title="0">{
                                                // set the streamBarIndex from which this indicator returns valid results
                                                ind.validFromBar = streamBarIndex
                                        }</span>

                                        <span class="cov8" title="358">if result &gt; ind.maxValue </span><span class="cov0" title="0">{
                                                // update the maximum result value
                                                ind.maxValue = result
                                        }</span>

                                        // update the minimum result value
                                        <span class="cov8" title="358">if result &lt; ind.minValue </span><span class="cov3" title="8">{
                                                ind.minValue = result
                                        }</span>

                                        // notify of a new result value though the value available action
                                        <span class="cov8" title="358">ind.valueAvailableAction(result, streamBarIndex)

                                        if tickData.L() &lt; ind.extremePoint </span><span class="cov6" title="78">{
                                                // adjust af and extremePoint
                                                ind.extremePoint = tickData.L()
                                                ind.acceleration += ind.accelerationFactor
                                                if ind.acceleration &gt; ind.accelerationFactorMax </span><span class="cov1" title="2">{
                                                        ind.acceleration = ind.accelerationFactorMax
                                                }</span>
                                        }

                                        // calculate the new Sar
                                        <span class="cov8" title="358">var diff float64 = ind.extremePoint - ind.previousSar
                                        ind.previousSar = ind.previousSar + ind.acceleration*(diff)

                                        // make sure the overridden Sar is within yesterdays and todays range
                                        if ind.previousSar &lt; ind.previousHigh </span><span class="cov4" title="18">{
                                                ind.previousSar = ind.previousHigh
                                        }</span>
                                        <span class="cov8" title="358">if ind.previousSar &lt; tickData.H() </span><span class="cov5" title="40">{
                                                ind.previousSar = tickData.H()
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov10" title="1319">ind.previousHigh = tickData.H()
        ind.previousLow = tickData.L()</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Simple Moving Average (Sma)
package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Simple Moving Average Indicator (Sma), no storage, for use in other indicators
type SmaWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodTotal          float64
        periodHistory        *list.List
        periodCounter        int
        valueAvailableAction ValueAvailableActionFloat
        timePeriod           int
}

// NewSmaWithoutStorage creates a Simple Moving Average Indicator (Sma) without storage
func NewSmaWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *SmaWithoutStorage, err error) <span class="cov6" title="178">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov6" title="178">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov6" title="178">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov6" title="178">lookback := timePeriod - 1
        ind := SmaWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        timePeriod * -1,
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Simple Moving Average Indicator (Sma)
type Sma struct {
        *SmaWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewSma creates a Simple Moving Average Indicator (Sma) for online usage
func NewSma(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Sma, err error) <span class="cov4" title="22">{
        ind := Sma{}
        ind.SmaWithoutStorage, err = NewSmaWithoutStorage(
                timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov7" title="1279">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)
        <span class="cov4" title="22">ind.selectData = selectData

        return &amp;ind, err</span>
}

// NewDefaultSma creates a Simple Moving Average Indicator (Sma) for online usage with default parameters
//        - timePeriod: 10
func NewDefaultSma() (indicator *Sma, err error) <span class="cov0" title="0">{
        timePeriod := 10
        return NewSma(timePeriod, gotrade.UseClosePrice)
}</span>

// NewSmaWithSrcLen creates a Simple Moving Average Indicator (Sma) for offline usage
func NewSmaWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Sma, err error) <span class="cov0" title="0">{
        ind, err := NewSma(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultSmaWithSrcLen creates a Simple Moving Average Indicator (Sma) for offline usage with default parameters
func NewDefaultSmaWithSrcLen(sourceLength int) (indicator *Sma, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultSma()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewSmaForStream creates a Simple Moving Average Indicator (Sma) for online usage with a source data stream
func NewSmaForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Sma, err error) <span class="cov0" title="0">{
        ind, err := NewSma(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultSmaForStream creates a Simple Moving Average Indicator (Sma) for online usage with a source data stream
func NewDefaultSmaForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Sma, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultSma()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewSmaForStreamWithSrcLen creates a Simple Moving Average Indicator (Sma) for offline usage with a source data stream
func NewSmaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Sma, err error) <span class="cov0" title="0">{
        ind, err := NewSmaWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultSmaForStreamWithSrcLen creates a Simple Moving Average Indicator (Sma) for offline usage with a source data stream
func NewDefaultSmaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Sma, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultSmaWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Sma) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov8" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *SmaWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="9931">{
        ind.periodCounter += 1
        ind.periodHistory.PushBack(tickData)

        if ind.periodCounter &gt; 0 </span><span class="cov9" title="9239">{
                var valueToRemove = ind.periodHistory.Front()
                ind.periodTotal -= valueToRemove.Value.(float64)
        }</span>
        <span class="cov10" title="9931">if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="9239">{
                var first = ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>
        <span class="cov10" title="9931">ind.periodTotal += tickData
        var result float64 = ind.periodTotal / float64(ind.timePeriod)
        if ind.periodCounter &gt;= 0 </span><span class="cov9" title="9353">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov5" title="114">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov9" title="9353">if result &gt; ind.maxValue </span><span class="cov8" title="1424">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="9353">if result &lt; ind.minValue </span><span class="cov7" title="543">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="9353">ind.valueAvailableAction(result, streamBarIndex)</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Standard Deviation Indicator (StdDev), no storage, for use in other indicators
type StdDevWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        variance             *VarWithoutStorage
        timePeriod           int
}

func NewStdDevWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *StdDevWithoutStorage, err error) <span class="cov5" title="44">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov5" title="44">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov5" title="44">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov5" title="44">lookback := timePeriod - 1

        ind := StdDevWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.valueAvailableAction = valueAvailableAction

        ind.variance, err = NewVarWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="2558">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="26">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                <span class="cov9" title="2558">result := math.Sqrt(dataItem)

                // update the maximum result value
                if result &gt; ind.maxValue </span><span class="cov6" title="170">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="2558">if result &lt; ind.minValue </span><span class="cov5" title="58">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="2558">ind.valueAvailableAction(result, streamBarIndex)</span>
        })

        <span class="cov5" title="44">return &amp;ind, err</span>
}

// A Standard Deviation Indicator (StdDev)
type StdDev struct {
        *StdDevWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewStdDev creates a Standard Deviation Indicator (StdDev) for online usage
func NewStdDev(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *StdDev, err error) <span class="cov4" title="22">{
        ind := StdDev{selectData: selectData}
        ind.StdDevWithoutStorage, err = NewStdDevWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov0" title="0">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">ind.valueAvailableAction = func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1279">{
                ind.Data = append(ind.Data, dataItem)
        }</span>
        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultStdDev creates a Standard Deviation Indicator (StdDev) for online usage with default parameters
//        - timePeriod: 10
func NewDefaultStdDev() (indicator *StdDev, err error) <span class="cov0" title="0">{
        timePeriod := 10
        return NewStdDev(timePeriod, gotrade.UseClosePrice)
}</span>

// NewStdDevWithSrcLen creates a Standard Deviation Indicator (StdDev) for offline usage
func NewStdDevWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *StdDev, err error) <span class="cov0" title="0">{
        ind, err := NewStdDev(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultStdDevWithSrcLen creates a Standard Deviation Indicator (StdDev) for offline usage with default parameters
func NewDefaultStdDevWithSrcLen(sourceLength int) (indicator *StdDev, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultStdDev()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewStdDevForStream creates a Standard Deviation Indicator (StdDev) for online usage with a source data stream
func NewStdDevForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *StdDev, err error) <span class="cov0" title="0">{
        ind, err := NewStdDev(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultStdDevForStream creates a Standard Deviation Indicator (StdDev) for online usage with a source data stream
func NewDefaultStdDevForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *StdDev, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultStdDev()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewStdDevForStreamWithSrcLen creates a Standard Deviation Indicator (StdDev) for offline usage with a source data stream
func NewStdDevForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *StdDev, err error) <span class="cov0" title="0">{
        ind, err := NewStdDevWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultStdDevForStreamWithSrcLen creates a Standard Deviation Indicator (StdDev) for offline usage with a source data stream
func NewDefaultStdDevForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *StdDev, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultStdDevWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (stdDev *StdDev) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov9" title="1327">{
        var selectedData = stdDev.selectData(tickData)
        stdDev.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (stdDev *StdDevWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="2654">{
        stdDev.variance.ReceiveTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Stochastic Oscillator Indicator (StochOsc), no storage, for use in other indicators
type StochOscWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionStoch
        periodCounter        int
        slowKMA              *SmaWithoutStorage
        slowDMA              *SmaWithoutStorage
        hhv                  *HhvWithoutStorage
        llv                  *LlvWithoutStorage
        currentPeriodHigh    float64
        currentPeriodLow     float64
        currentFastK         float64
        currentSlowKMA       float64
        currentSlowDMA       float64
}

// NewStochOscWithoutStorage creates a Stochastic Oscillator Indicator (StochOsc) without storage
func NewStochOscWithoutStorage(fastKTimePeriod int, slowKTimePeriod int, slowDTimePeriod int, valueAvailableAction ValueAvailableActionStoch) (indicator *StochOscWithoutStorage, err error) <span class="cov4" title="23">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum fastKTimePeriod for this indicator is 1
        <span class="cov4" title="23">if fastKTimePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("fastKTimePeriod is less than the minimum (1)")
        }</span>

        // check the maximum fastKTimePeriod
        <span class="cov4" title="23">if fastKTimePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("fastKTimePeriod is greater than the maximum (100000)")
        }</span>

        // the minimum slowKTimePeriod for this indicator is 1
        <span class="cov4" title="23">if slowKTimePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("slowKTimePeriod is less than the minimum (1)")
        }</span>

        // check the maximum slowKTimePeriod
        <span class="cov4" title="23">if slowKTimePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("slowKTimePeriod is greater than the maximum (100000)")
        }</span>

        // the minimum slowDTimePeriod for this indicator is 1
        <span class="cov4" title="23">if slowDTimePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("slowDTimePeriod is less than the minimum (1)")
        }</span>

        // check the maximum slowDTimePeriod
        <span class="cov4" title="23">if slowDTimePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("slowDTimePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="23">ind := StochOscWithoutStorage{
                baseFloatBounds:      newBaseFloatBounds(),
                currentSlowKMA:       0.0,
                currentSlowDMA:       0.0,
                periodCounter:        (fastKTimePeriod * -1),
                valueAvailableAction: valueAvailableAction,
        }

        tmpSlowKMA, err := NewSmaWithoutStorage(slowKTimePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1518">{
                ind.currentSlowKMA = dataItem
                ind.slowDMA.ReceiveTick(ind.currentSlowKMA, streamBarIndex)
        }</span>)

        <span class="cov4" title="23">tmpSlowDMA, err := NewSmaWithoutStorage(slowDTimePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1482">{
                ind.currentSlowDMA = dataItem

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="14">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                <span class="cov9" title="1482">var max = math.Max(ind.currentSlowKMA, ind.currentSlowDMA)
                var min = math.Min(ind.currentSlowKMA, ind.currentSlowDMA)

                // update the maximum result value
                if max &gt; ind.maxValue </span><span class="cov4" title="26">{
                        ind.maxValue = max
                }</span>

                // update the minimum result value
                <span class="cov9" title="1482">if min &lt; ind.minValue </span><span class="cov6" title="95">{
                        ind.minValue = min
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1482">ind.valueAvailableAction(ind.currentSlowKMA, ind.currentSlowDMA, streamBarIndex)</span>
        })

        <span class="cov4" title="23">lookback := fastKTimePeriod - 1 + tmpSlowDMA.GetLookbackPeriod() + tmpSlowKMA.GetLookbackPeriod()

        ind.baseIndicator = newBaseIndicator(lookback)
        ind.slowKMA = tmpSlowKMA
        ind.slowDMA = tmpSlowDMA
        ind.hhv, err = NewHhvWithoutStorage(fastKTimePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1554">{
                ind.currentPeriodHigh = dataItem
        }</span>)
        <span class="cov4" title="23">ind.llv, err = NewLlvWithoutStorage(fastKTimePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1554">{
                ind.currentPeriodLow = dataItem
        }</span>)

        <span class="cov4" title="23">return &amp;ind, err</span>
}

// A Stochastic Oscillator Indicator (StochOsc)
type StochOsc struct {
        *StochOscWithoutStorage

        // public variables
        SlowK []float64
        SlowD []float64
}

// NewStochOsc creates a Stochastic Oscillator Indicator (StochOsc) for online usage
func NewStochOsc(fastKTimePeriod int, slowKTimePeriod int, slowDTimePeriod int) (indicator *StochOsc, err error) <span class="cov4" title="23">{
        ind := StochOsc{}
        ind.StochOscWithoutStorage, err = NewStochOscWithoutStorage(fastKTimePeriod, slowKTimePeriod, slowDTimePeriod,
                func(dataItemK float64, dataItemD float64, streamBarIndex int) </span><span class="cov9" title="1482">{
                        ind.SlowK = append(ind.SlowK, dataItemK)
                        ind.SlowD = append(ind.SlowD, dataItemD)
                }</span>)

        <span class="cov4" title="23">return &amp;ind, err</span>
}

// NewDefaultStochOsc creates a Stochastic Oscillator Indicator (StochOsc) for online usage with default parameters
//        - fastKTimePeriod : 5
//  - slowKTimePeriod : 3
//  - slowDTimePeriod : 3
func NewDefaultStochOsc() (indicator *StochOsc, err error) <span class="cov0" title="0">{
        fastKTimePeriod := 5
        slowKTimePeriod := 3
        slowDTimePeriod := 3
        return NewStochOsc(fastKTimePeriod, slowKTimePeriod, slowDTimePeriod)
}</span>

// NewStochOscWithSrcLen creates a Stochastic Oscillator Indicator (StochOsc) for offline usage
func NewStochOscWithSrcLen(sourceLength int, fastKTimePeriod int, slowKTimePeriod int, slowDTimePeriod int) (indicator *StochOsc, err error) <span class="cov0" title="0">{
        ind, err := NewStochOsc(fastKTimePeriod, slowKTimePeriod, slowDTimePeriod)
        ind.SlowK = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.SlowD = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewDefaultStochOscWithSrcLen creates a Stochastic Oscillator Indicator (StochOsc) for offline usage with default parameters
func NewDefaultStochOscWithSrcLen(sourceLength int) (indicator *StochOsc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultStochOsc()
        ind.SlowK = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        ind.SlowD = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewStochOscForStream creates a Stochastic Oscillator Indicator (StochOsc) for online usage with a source data stream
func NewStochOscForStream(priceStream gotrade.DOHLCVStreamSubscriber, fastKTimePeriod int, slowKTimePeriod int, slowDTimePeriod int) (indicator *StochOsc, err error) <span class="cov0" title="0">{
        ind, err := NewStochOsc(fastKTimePeriod, slowKTimePeriod, slowDTimePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultStochOscForStream creates a Stochastic Oscillator Indicator (StochOsc) for online usage with a source data stream
func NewDefaultStochOscForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *StochOsc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultStochOsc()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewStochOscForStreamWithSrcLen creates a Stochastic Oscillator Indicator (StochOsc) for offline usage with a source data stream
func NewStochOscForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, fastKTimePeriod int, slowKTimePeriod int, slowDTimePeriod int) (indicator *StochOsc, err error) <span class="cov0" title="0">{
        ind, err := NewStochOscWithSrcLen(sourceLength, fastKTimePeriod, slowKTimePeriod, slowDTimePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultStochOscForStreamWithSrcLen creates a Stochastic Oscillator Indicator (StochOsc) for offline usage with a source data stream
func NewDefaultStochOscForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *StochOsc, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultStochOscWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *StochOscWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1626">{
        ind.periodCounter += 1
        ind.hhv.ReceiveTick(tickData.H(), streamBarIndex)
        ind.llv.ReceiveTick(tickData.L(), streamBarIndex)

        if ind.periodCounter &gt;= 0 </span><span class="cov9" title="1554">{
                ind.currentFastK = 100.0 * ((tickData.C() - ind.currentPeriodLow) / (ind.currentPeriodHigh - ind.currentPeriodLow))
                ind.slowKMA.ReceiveTick(ind.currentFastK, streamBarIndex)
        }</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package indicators

// Tema(X) = (2 * EMA(X, CLOSE)) - (EMA(X, EMA(X, CLOSE)))

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Tripple Exponential Moving Average Indicator (Tema), no storage, for use in other indicators
type TemaWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        ema1                 *EmaWithoutStorage
        ema2                 *EmaWithoutStorage
        ema3                 *EmaWithoutStorage
        currentEMA           float64
        currentEMA2          float64
        timePeriod           int
}

func NewTemaWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *TemaWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := 3 * (timePeriod - 1)
        ind := TemaWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        ind.ema1, err = NewEmaWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1311">{
                ind.currentEMA = dataItem
                ind.ema2.ReceiveTick(dataItem, streamBarIndex)
        }</span>)

        <span class="cov4" title="22">ind.ema2, _ = NewEmaWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1263">{
                ind.currentEMA2 = dataItem
                ind.ema3.ReceiveTick(dataItem, streamBarIndex)
        }</span>)

        <span class="cov4" title="22">ind.ema3, _ = NewEmaWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1215">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                //TEMA = (3*EMA  3*EMA(EMA)) + EMA(EMA(EMA))
                <span class="cov9" title="1215">tema := (3*ind.currentEMA - 3*ind.currentEMA2) + dataItem

                // update the maximum result value
                if tema &gt; ind.maxValue </span><span class="cov7" title="174">{
                        ind.maxValue = tema
                }</span>

                // update the minimum result value
                <span class="cov9" title="1215">if tema &lt; ind.minValue </span><span class="cov5" title="47">{
                        ind.minValue = tema
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1215">ind.valueAvailableAction(tema, streamBarIndex)</span>
        })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// A Tripple Exponential Moving Average Indicator (Tema)
type Tema struct {
        *TemaWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewTema creates a Tripple Exponential Moving Average Indicator (Tema) for online usage
func NewTema(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Tema, err error) <span class="cov4" title="22">{
        ind := Tema{selectData: selectData}
        ind.TemaWithoutStorage, err = NewTemaWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1215">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)
        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultTema creates a Tripple Exponential Moving Average Indicator (Tema) for online usage with default parameters
//        - timePeriod: 30
func NewDefaultTema() (indicator *Tema, err error) <span class="cov0" title="0">{
        timePeriod := 30
        return NewTema(timePeriod, gotrade.UseClosePrice)
}</span>

// NewTemaWithSrcLen creates a Tripple Exponential Moving Average Indicator (Tema) for offline usage
func NewTemaWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Tema, err error) <span class="cov0" title="0">{
        ind, err := NewTema(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultTemaWithSrcLen creates a Tripple Exponential Moving Average Indicator (Tema) for offline usage with default parameters
func NewDefaultTemaWithSrcLen(sourceLength int) (indicator *Tema, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultTema()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewTemaForStream creates a Tripple Exponential Moving Average Indicator (Tema) for online usage with a source data stream
func NewTemaForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Tema, err error) <span class="cov0" title="0">{
        ind, err := NewTema(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultTemaForStream creates a Tripple Exponential Moving Average Indicator (Tema) for online usage with a source data stream
func NewDefaultTemaForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Tema, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultTema()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewTemaForStreamWithSrcLen creates a Tripple Exponential Moving Average Indicator (Tema) for offline usage with a source data stream
func NewTemaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Tema, err error) <span class="cov0" title="0">{
        ind, err := NewTemaWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultTemaForStreamWithSrcLen creates a Tripple Exponential Moving Average Indicator (Tema) for offline usage with a source data stream
func NewDefaultTemaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Tema, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultTemaWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (tema *Tema) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1359">{
        var selectedData = tema.selectData(tickData)
        tema.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (tema *TemaWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1359">{
        tema.ema1.ReceiveTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package indicators

import (
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Triangular Moving Average Indicator (Trima), no storage, for use in other indicators
type TrimaWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
        sma1                 *SmaWithoutStorage
        sma2                 *SmaWithoutStorage
        currentSma           float64
        timePeriod           int
}

// NewTrimaWithoutStorage creates a Triangular Moving Average Indicator (Trima) without storage
func NewTrimaWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *TrimaWithoutStorage, err error) <span class="cov4" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov4" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov4" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov4" title="22">lookback := timePeriod - 1
        ind := TrimaWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        var sma1Period int
        var sma2Period int

        if timePeriod%2 == 0 </span><span class="cov4" title="22">{
                // even
                sma1Period = timePeriod / 2
                sma2Period = (timePeriod / 2) + 1
        }</span> <span class="cov0" title="0">else {
                // odd
                sma1Period = (timePeriod + 1) / 2
                sma2Period = (timePeriod + 1) / 2
        }</span>

        <span class="cov4" title="22">ind.sma1, err = NewSmaWithoutStorage(sma1Period, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1293">{
                ind.currentSma = dataItem
                ind.sma2.ReceiveTick(dataItem, streamBarIndex)
        }</span>)

        <span class="cov4" title="22">ind.sma2, _ = NewSmaWithoutStorage(sma2Period, func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1218">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                <span class="cov9" title="1218">result := dataItem

                // update the maximum result value
                if result &gt; ind.maxValue </span><span class="cov8" title="300">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="1218">if result &lt; ind.minValue </span><span class="cov6" title="67">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="1218">ind.valueAvailableAction(result, streamBarIndex)</span>
        })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// A Triangular Moving Average Indicator (Trima)
type Trima struct {
        *TrimaWithoutStorage
        selectData gotrade.DataSelectionFunc
        // public variables
        Data []float64
}

// NewTrima creates a Triangular Moving Average Indicator (Trima) for online usage
func NewTrima(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Trima, err error) <span class="cov4" title="22">{
        ind := Trima{selectData: selectData}
        ind.TrimaWithoutStorage, err = NewTrimaWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1218">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)
        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultTrima creates a Triangular Moving Average Indicator (Trima) for online usage with default parameters
//        - timePeriod: 30
func NewDefaultTrima() (indicator *Trima, err error) <span class="cov0" title="0">{
        timePeriod := 30
        return NewTrima(timePeriod, gotrade.UseClosePrice)
}</span>

// NewTrimaWithSrcLen creates a Triangular Moving Average Indicator (Trima) for offline usage
func NewTrimaWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Trima, err error) <span class="cov0" title="0">{
        ind, err := NewTrima(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultTrimaWithSrcLen creates a Triangular Moving Average Indicator (Trima) for offline usage with default parameters
func NewDefaultTrimaWithSrcLen(sourceLength int) (indicator *Trima, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultTrima()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewTrimaForStream creates a Triangular Moving Average Indicator (Trima) for online usage with a source data stream
func NewTrimaForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Trima, err error) <span class="cov0" title="0">{
        ind, err := NewTrima(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultTrimaForStream creates a Triangular Moving Average Indicator (Trima) for online usage with a source data stream
func NewDefaultTrimaForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Trima, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultTrima()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewTrimaForStreamWithSrcLen creates a Triangular Moving Average Indicator (Trima) for offline usage with a source data stream
func NewTrimaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Trima, err error) <span class="cov0" title="0">{
        ind, err := NewTrimaWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultTrimaForStreamWithSrcLen creates a Triangular Moving Average Indicator (Trima) for offline usage with a source data stream
func NewDefaultTrimaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Trima, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultTrimaWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (tema *Trima) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1351">{
        var selectedData = tema.selectData(tickData)
        tema.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (tema *TrimaWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="1351">{
        tema.sma1.ReceiveTick(tickData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package indicators

import (
        "github.com/thetruetrade/gotrade"
        "math"
)

// TrueHigh = Max(High[0], Close[-1])
// TrueLow = Min(Low[0], Close[-1])
// TrueRange = TrueHigh = TrueLow

// A True Range Indicator (TrueRange), no storage, for use in other indicators
type TrueRangeWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodCounter        int
        previousClose        float64
        valueAvailableAction ValueAvailableActionFloat
}

// NewTrueRangeWithoutStorage creates a True Range Indicator (TrueRange) without storage
func NewTrueRangeWithoutStorage(valueAvailableAction ValueAvailableActionFloat) (indicator *TrueRangeWithoutStorage, err error) <span class="cov6" title="524">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        <span class="cov6" title="524">lookback := 1
        ind := TrueRangeWithoutStorage{
                baseIndicator:   newBaseIndicator(lookback),
                baseFloatBounds: newBaseFloatBounds(),
                periodCounter:   -1,
                previousClose:   0.0,
        }
        ind.valueAvailableAction = valueAvailableAction
        return &amp;ind, nil</span>
}

// A True Range Indicator (TrueRange)
type TrueRange struct {
        *TrueRangeWithoutStorage

        // public variables
        Data []float64
}

// NewTrueRange creates a True Range Indicator (TrueRange) for online usage
func NewTrueRange() (indicator *TrueRange, err error) <span class="cov6" title="502">{
        ind := TrueRange{}
        ind.TrueRangeWithoutStorage, err = NewTrueRangeWithoutStorage(func(dataItem float64, streamBarIndex int) </span><span class="cov7" title="1302">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)
        <span class="cov6" title="502">return &amp;ind, err</span>
}

// NewTrueRangeWithSrcLen creates a True Range Indicator (TrueRange) for offline usage
func NewTrueRangeWithSrcLen(sourceLength int) (indicator *TrueRange, err error) <span class="cov0" title="0">{
        ind, err := NewTrueRange()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewTrueRangeForStream creates a True Range Indicator (TrueRange) for online usage with a source data stream
func NewTrueRangeForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *TrueRange, err error) <span class="cov0" title="0">{
        ind, err := NewTrueRange()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewTrueRangeForStreamWithSrcLen creates a True Range Indicator (TrueRange) for offline usage with a source data stream
func NewTrueRangeForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *TrueRange, err error) <span class="cov0" title="0">{
        ind, err := NewTrueRangeWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *TrueRangeWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="30674">{
        ind.periodCounter += 1

        if ind.periodCounter &gt; 0 </span><span class="cov9" title="30372">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov5" title="298">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>
                <span class="cov9" title="30372">high := math.Max(tickData.H(), ind.previousClose)
                low := math.Min(tickData.L(), ind.previousClose)
                trueRange := high - low

                // update the maximum result value
                if trueRange &gt; ind.maxValue </span><span class="cov6" title="640">{
                        ind.maxValue = trueRange
                }</span>

                // update the minimum result value
                <span class="cov9" title="30372">if trueRange &lt; ind.minValue </span><span class="cov6" title="490">{
                        ind.minValue = trueRange
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="30372">ind.valueAvailableAction(trueRange, streamBarIndex)</span>
        }
        <span class="cov10" title="30674">ind.previousClose = tickData.C()</span>

}
</pre>
		
		<pre class="file" id="file44" style="display: none">package indicators

import (
        "github.com/thetruetrade/gotrade"
)

// A Time Series Forecast Indicator (Tsf)
type Tsf struct {
        *LinRegWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewTsf creates a Time Series Forecast Indicator (Tsf) for online usage
func NewTsf(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Tsf, err error) <span class="cov4" title="22">{
        ind := Tsf{selectData: selectData}
        ind.LinRegWithoutStorage, err = NewLinRegWithoutStorage(timePeriod,
                func(dataItem float64, slope float64, intercept float64, streamBarIndex int) </span><span class="cov9" title="1271">{
                        result := intercept + slope*float64(timePeriod)

                        // update the maximum result value
                        if result &gt; ind.LinRegWithoutStorage.maxValue </span><span class="cov7" title="206">{
                                ind.LinRegWithoutStorage.maxValue = result
                        }</span>

                        // update the minimum result value
                        <span class="cov9" title="1271">if result &lt; ind.LinRegWithoutStorage.minValue </span><span class="cov5" title="43">{
                                ind.LinRegWithoutStorage.minValue = result
                        }</span>

                        <span class="cov9" title="1271">ind.Data = append(ind.Data, result)</span>
                })

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultTsf creates a Time Series Forecast Indicator (Tsf) for online usage with default parameters
//        - timePeriod: 10
func NewDefaultTsf() (indicator *Tsf, err error) <span class="cov0" title="0">{
        timePeriod := 10
        return NewTsf(timePeriod, gotrade.UseClosePrice)
}</span>

// NewTsfWithSrcLen creates a Time Series Forecast Indicator (Tsf) for offline usage
func NewTsfWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Tsf, err error) <span class="cov0" title="0">{
        ind, err := NewTsf(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultTsfWithSrcLen creates a Time Series Forecast Indicator (Tsf) for offline usage with default parameters
func NewDefaultTsfWithSrcLen(sourceLength int) (indicator *Tsf, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultTsf()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewTsfForStream creates a Time Series Forecast Indicator (Tsf) for online usage with a source data stream
func NewTsfForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Tsf, err error) <span class="cov0" title="0">{
        ind, err := NewTsf(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultTsfForStream creates a Time Series Forecast Indicator (Tsf) for online usage with a source data stream
func NewDefaultTsfForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Tsf, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultTsf()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewTsfForStreamWithSrcLen creates a Time Series Forecast Indicator (Tsf) for offline usage with a source data stream
func NewTsfForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Tsf, err error) <span class="cov0" title="0">{
        ind, err := NewTsfWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultTsfForStreamWithSrcLen creates a Time Series Forecast Indicator (Tsf) for offline usage with a source data stream
func NewDefaultTsfForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Tsf, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultTsfWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Tsf) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package indicators

import (
        "github.com/thetruetrade/gotrade"
)

type TypPriceWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        valueAvailableAction ValueAvailableActionFloat
}

func NewTypPriceWithoutStorage(valueAvailableAction ValueAvailableActionFloat) (indicator *TypPriceWithoutStorage, err error) <span class="cov5" title="44">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        <span class="cov5" title="44">lookback := 0
        ind := TypPriceWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                valueAvailableAction: valueAvailableAction,
        }

        return &amp;ind, nil</span>
}

// A Typical Price Indicator (TypPrice)
type TypPrice struct {
        *TypPriceWithoutStorage

        // public variables
        Data []float64
}

// NewTypPrice creates a Typical Price Indicator (TypPrice) for online usage
func NewTypPrice() (indicator *TypPrice, err error) <span class="cov4" title="22">{
        ind := TypPrice{}
        ind.TypPriceWithoutStorage, err = NewTypPriceWithoutStorage(func(dataItem float64, streamBarIndex int) </span><span class="cov9" title="1311">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewTypPriceWithSrcLen creates a Typical Price Indicator (TypPrice) for offline usage
func NewTypPriceWithSrcLen(sourceLength int) (indicator *TypPrice, err error) <span class="cov0" title="0">{
        ind, err := NewTypPrice()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewTypPriceForStream creates a Typical Price Indicator (TypPrice) for online usage with a source data stream
func NewTypPriceForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *TypPrice, err error) <span class="cov0" title="0">{
        ind, err := NewTypPrice()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewTypPriceForStreamWithSrcLen creates a Typical Price Indicator (TypPrice) for offline usage with a source data stream
func NewTypPriceForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *TypPrice, err error) <span class="cov0" title="0">{
        ind, err := NewTypPriceWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *TypPriceWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov10" title="2734">{

        // increment the number of results this indicator can be expected to return
        ind.dataLength += 1

        if ind.validFromBar == -1 </span><span class="cov4" title="30">{
                // set the streamBarIndex from which this indicator returns valid results
                ind.validFromBar = streamBarIndex
        }</span>

        <span class="cov10" title="2734">result := (tickData.H() + tickData.L() + tickData.C()) / float64(3.0)

        // update the maximum result value
        if result &gt; ind.maxValue </span><span class="cov8" title="536">{
                ind.maxValue = result
        }</span>

        // update the minimum result value
        <span class="cov10" title="2734">if result &lt; ind.minValue </span><span class="cov5" title="70">{
                ind.minValue = result
        }</span>

        // notify of a new result value though the value available action
        <span class="cov10" title="2734">ind.valueAvailableAction(result, streamBarIndex)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Variance Indicator (Var), no storage, for use in other indicators
type VarWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodCounter        int
        periodHistory        *list.List
        mean                 float64
        variance             float64
        valueAvailableAction ValueAvailableActionFloat
        timePeriod           int
}

// NewVarWithoutStorage creates a Variance Indicator (Var) without storage
func NewVarWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *VarWithoutStorage, err error) <span class="cov5" title="66">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 1
        <span class="cov5" title="66">if timePeriod &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (1)")
        }</span>

        // check the maximum timeperiod
        <span class="cov5" title="66">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov5" title="66">lookback := timePeriod - 1

        ind := VarWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        0,
                periodHistory:        list.New(),
                mean:                 0.0,
                variance:             0.0,
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Variance Indicator (Var)
type Var struct {
        *VarWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewVar creates a Variance Indicator (Var) for online usage
func NewVar(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Var, err error) <span class="cov4" title="22">{
        ind := Var{selectData: selectData}
        ind.VarWithoutStorage, err = NewVarWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov8" title="1279">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)

        <span class="cov4" title="22">return &amp;ind, err</span>
}

// NewDefaultVar creates a Variance Indicator (Var) for online usage with default parameters
//        - timePeriod: 10
func NewDefaultVar() (indicator *Var, err error) <span class="cov0" title="0">{
        timePeriod := 10
        return NewVar(timePeriod, gotrade.UseClosePrice)
}</span>

// NewVarWithSrcLen creates a Variance Indicator (Var) for offline usage
func NewVarWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Var, err error) <span class="cov0" title="0">{
        ind, err := NewVar(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultVarWithSrcLen creates a Variance Indicator (Var) for offline usage with default parameters
func NewDefaultVarWithSrcLen(sourceLength int) (indicator *Var, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultVar()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewVarForStream creates a Variance Indicator (Var) for online usage with a source data stream
func NewVarForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Var, err error) <span class="cov0" title="0">{
        ind, err := NewVar(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultVarForStream creates a Variance Indicator (Var) for online usage with a source data stream
func NewDefaultVarForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Var, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultVar()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewVarForStreamWithSrcLen creates a Variance Indicator (Var) for offline usage with a source data stream
func NewVarForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Var, err error) <span class="cov0" title="0">{
        ind, err := NewVarWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultVarForStreamWithSrcLen creates a Variance Indicator (Var) for offline usage with a source data stream
func NewDefaultVarForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Var, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultVarWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Var) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov8" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

// http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance - Knuth
func (ind *VarWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov10" title="3981">{
        ind.periodHistory.PushBack(tickData)
        firstValue := ind.periodHistory.Front().Value.(float64)

        previousMean := ind.mean
        previousVar := ind.variance

        if ind.periodCounter &lt; ind.timePeriod </span><span class="cov6" title="183">{
                ind.periodCounter += 1
                delta := tickData - previousMean
                ind.mean = previousMean + delta/float64(ind.periodCounter)

                ind.variance = previousVar + delta*(tickData-ind.mean)
        }</span> <span class="cov9" title="3798">else {
                delta := tickData - firstValue
                dOld := firstValue - previousMean
                ind.mean = previousMean + delta/float64(ind.periodCounter)
                dNew := tickData - ind.mean
                ind.variance = previousVar + (dOld+dNew)*(delta)
        }</span>

        <span class="cov10" title="3981">if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov9" title="3798">{
                first := ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>

        <span class="cov10" title="3981">if ind.periodCounter &gt;= ind.timePeriod </span><span class="cov9" title="3837">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov4" title="39">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                <span class="cov9" title="3837">result := ind.variance / float64(ind.timePeriod)

                // update the maximum result value
                if result &gt; ind.maxValue </span><span class="cov7" title="255">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov9" title="3837">if result &lt; ind.minValue </span><span class="cov5" title="87">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov9" title="3837">ind.valueAvailableAction(result, streamBarIndex)</span>
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
        "math"
)

// A Williamns Percent R Indicator
type WillRWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodHighHistory    *list.List
        periodLowHistory     *list.List
        periodCounter        int
        valueAvailableAction ValueAvailableActionFloat
        timePeriod           int
}

// NewWillRWithoutStorage creates a Williams Percent R Indicator (WillR) without storage
func NewWillRWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *WillRWithoutStorage, err error) <span class="cov3" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov3" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov3" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov3" title="22">lookback := timePeriod - 1
        ind := WillRWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        timePeriod * -1,
                periodHighHistory:    list.New(),
                periodLowHistory:     list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        return &amp;ind, nil</span>
}

// A Simple Moving Average Indicator
type WillR struct {
        *WillRWithoutStorage

        // public variables
        Data []float64
}

// NewWillR creates a Williams Percent R Indicator (WillR) for online usage
func NewWillR(timePeriod int) (indicator *WillR, err error) <span class="cov3" title="22">{
        ind := WillR{}
        ind.WillRWithoutStorage, err = NewWillRWithoutStorage(timePeriod, func(dataItem float64, streamBarIndex int) </span><span class="cov7" title="1250">{
                ind.Data = append(ind.Data, dataItem)
        }</span>)

        <span class="cov3" title="22">return &amp;ind, err</span>
}

// NewDefaultWillR creates a Williams Percent R Indicator (WillR) for online usage with default parameters
//        - timePeriod: 14
func NewDefaultWillR() (indicator *WillR, err error) <span class="cov0" title="0">{
        timePeriod := 14
        return NewWillR(timePeriod)
}</span>

// NewWillRWithSrcLen creates a Williams Percent R Indicator (WillR) for offline usage
func NewWillRWithSrcLen(sourceLength int, timePeriod int) (indicator *WillR, err error) <span class="cov0" title="0">{
        ind, err := NewWillR(timePeriod)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultWillRWithSrcLen creates a Williams Percent R Indicator (WillR) for offline usage with default parameters
func NewDefaultWillRWithSrcLen(sourceLength int) (indicator *WillR, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultWillR()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewWillRForStream creates a Williams Percent R Indicator (WillR) for online usage with a source data stream
func NewWillRForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *WillR, err error) <span class="cov0" title="0">{
        ind, err := NewWillR(timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultWillRForStream creates a Williams Percent R Indicator (WillR) for online usage with a source data stream
func NewDefaultWillRForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *WillR, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultWillR()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewWillRForStreamWithSrcLen creates a Williams Percent R Indicator (WillR) for offline usage with a source data stream
func NewWillRForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int) (indicator *WillR, err error) <span class="cov0" title="0">{
        ind, err := NewWillRWithSrcLen(sourceLength, timePeriod)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultWillRForStreamWithSrcLen creates a Williams Percent R Indicator (WillR) for offline usage with a source data stream
func NewDefaultWillRForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *WillR, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultWillRWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *WillRWithoutStorage) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov7" title="1351">{

        ind.periodCounter += 1
        ind.periodHighHistory.PushBack(tickData.H())
        ind.periodLowHistory.PushBack(tickData.L())

        highestHigh, _ := highestHighofPeriod(ind.periodHighHistory)
        lowestLow, _ := lowestLowofPeriod(ind.periodLowHistory)

        var result float64 = (highestHigh - tickData.C()) / (highestHigh - lowestLow) * -100.0
        if ind.periodCounter &gt;= 0 </span><span class="cov7" title="1250">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1

                if ind.validFromBar == -1 </span><span class="cov3" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // update the maximum result value
                <span class="cov7" title="1250">if result &gt; ind.maxValue </span><span class="cov0" title="0">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov7" title="1250">if result &lt; ind.minValue </span><span class="cov5" title="74">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov7" title="1250">ind.valueAvailableAction(result, streamBarIndex)</span>
        }

        <span class="cov7" title="1351">if ind.periodHighHistory.Len() &gt;= ind.timePeriod </span><span class="cov7" title="1250">{
                var first = ind.periodHighHistory.Front()
                ind.periodHighHistory.Remove(first)
        }</span>
        <span class="cov7" title="1351">if ind.periodLowHistory.Len() &gt;= ind.timePeriod </span><span class="cov7" title="1250">{
                var first = ind.periodLowHistory.Front()
                ind.periodLowHistory.Remove(first)
        }</span>
}

func highestHighofPeriod(l *list.List) (result float64, err error) <span class="cov7" title="1351">{
        if l.Len() == 0 </span><span class="cov0" title="0">{
                err = errors.New("list is empty no high can be calculated.")
        }</span>

        <span class="cov7" title="1351">high := math.SmallestNonzeroFloat64
        for e := l.Front(); e != nil; e = e.Next() </span><span class="cov10" title="11715">{
                value := e.Value.(float64)
                if value &gt; high </span><span class="cov9" title="4712">{
                        high = value
                }</span>
        }
        <span class="cov7" title="1351">return high, err</span>
}

func lowestLowofPeriod(l *list.List) (result float64, err error) <span class="cov7" title="1351">{
        if l.Len() == 0 </span><span class="cov0" title="0">{
                err = errors.New("list is empty no low can be calculated.")
        }</span>

        <span class="cov7" title="1351">low := math.MaxFloat64
        for e := l.Front(); e != nil; e = e.Next() </span><span class="cov10" title="11715">{
                value := e.Value.(float64)
                if value &lt; low </span><span class="cov8" title="2763">{
                        low = value
                }</span>
        }

        <span class="cov7" title="1351">return low, err</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package indicators

import (
        "container/list"
        "errors"
        "github.com/thetruetrade/gotrade"
)

// A Weighted Moving Average Indicator (Wma), no storage, for use in other indicators
type WmaWithoutStorage struct {
        *baseIndicator
        *baseFloatBounds

        // private variables
        periodTotal          float64
        periodHistory        *list.List
        periodCounter        int
        periodWeightTotal    int
        valueAvailableAction ValueAvailableActionFloat
        timePeriod           int
}

// NewWmaWithoutStorage creates a Weighted Moving Average Indicator (Wma) without storage
func NewWmaWithoutStorage(timePeriod int, valueAvailableAction ValueAvailableActionFloat) (indicator *WmaWithoutStorage, err error) <span class="cov3" title="22">{

        // an indicator without storage MUST have a value available action
        if valueAvailableAction == nil </span><span class="cov0" title="0">{
                return nil, ErrValueAvailableActionIsNil
        }</span>

        // the minimum timeperiod for this indicator is 2
        <span class="cov3" title="22">if timePeriod &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is less than the minimum (2)")
        }</span>

        // check the maximum timeperiod
        <span class="cov3" title="22">if timePeriod &gt; MaximumLookbackPeriod </span><span class="cov0" title="0">{
                return nil, errors.New("timePeriod is greater than the maximum (100000)")
        }</span>

        <span class="cov3" title="22">lookback := timePeriod - 1
        ind := WmaWithoutStorage{
                baseIndicator:        newBaseIndicator(lookback),
                baseFloatBounds:      newBaseFloatBounds(),
                periodCounter:        timePeriod * -1,
                periodHistory:        list.New(),
                valueAvailableAction: valueAvailableAction,
                timePeriod:           timePeriod,
        }

        var weightedTotal int = 0
        for i := 1; i &lt;= timePeriod; i++ </span><span class="cov4" title="80">{
                weightedTotal += i
        }</span>
        <span class="cov3" title="22">ind.periodWeightTotal = weightedTotal

        return &amp;ind, nil</span>
}

// A Weighted Moving Average Indicator (Wma)
type Wma struct {
        *WmaWithoutStorage
        selectData gotrade.DataSelectionFunc

        // public variables
        Data []float64
}

// NewWma creates a Weighted Moving Average Indicator (Wma) for online usage
func NewWma(timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Wma, err error) <span class="cov3" title="22">{
        ind := Wma{selectData: selectData}
        ind.WmaWithoutStorage, err = NewWmaWithoutStorage(timePeriod,
                func(dataItem float64, streamBarIndex int) </span><span class="cov7" title="1279">{
                        ind.Data = append(ind.Data, dataItem)
                }</span>)
        <span class="cov3" title="22">return &amp;ind, err</span>
}

// NewDefaultWma creates a Weighted Moving Average Indicator (Wma) for online usage with default parameters
//        - timePeriod: 10
func NewDefaultWma() (indicator *Wma, err error) <span class="cov0" title="0">{
        timePeriod := 10
        return NewWma(timePeriod, gotrade.UseClosePrice)
}</span>

// NewWmaWithSrcLen creates a Weighted Moving Average Indicator (Wma) for offline usage
func NewWmaWithSrcLen(sourceLength int, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Wma, err error) <span class="cov0" title="0">{
        ind, err := NewWma(timePeriod, selectData)
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())

        return ind, err
}</span>

// NewDefaultWmaWithSrcLen creates a Weighted Moving Average Indicator (Wma) for offline usage with default parameters
func NewDefaultWmaWithSrcLen(sourceLength int) (indicator *Wma, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultWma()
        ind.Data = make([]float64, 0, sourceLength-ind.GetLookbackPeriod())
        return ind, err
}</span>

// NewWmaForStream creates a Weighted Moving Average Indicator (Wma) for online usage with a source data stream
func NewWmaForStream(priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Wma, err error) <span class="cov0" title="0">{
        ind, err := NewWma(timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultWmaForStream creates a Weighted Moving Average Indicator (Wma) for online usage with a source data stream
func NewDefaultWmaForStream(priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Wma, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultWma()
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewWmaForStreamWithSrcLen creates a Weighted Moving Average Indicator (Wma) for offline usage with a source data stream
func NewWmaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DataSelectionFunc) (indicator *Wma, err error) <span class="cov0" title="0">{
        ind, err := NewWmaWithSrcLen(sourceLength, timePeriod, selectData)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// NewDefaultWmaForStreamWithSrcLen creates a Weighted Moving Average Indicator (Wma) for offline usage with a source data stream
func NewDefaultWmaForStreamWithSrcLen(sourceLength int, priceStream gotrade.DOHLCVStreamSubscriber) (indicator *Wma, err error) <span class="cov0" title="0">{
        ind, err := NewDefaultWmaWithSrcLen(sourceLength)
        priceStream.AddTickSubscription(ind)
        return ind, err
}</span>

// ReceiveDOHLCVTick consumes a source data DOHLCV price tick
func (ind *Wma) ReceiveDOHLCVTick(tickData gotrade.DOHLCV, streamBarIndex int) <span class="cov7" title="1327">{
        var selectedData = ind.selectData(tickData)
        ind.ReceiveTick(selectedData, streamBarIndex)
}</span>

func (ind *WmaWithoutStorage) ReceiveTick(tickData float64, streamBarIndex int) <span class="cov7" title="1327">{
        ind.periodCounter += 1

        ind.periodHistory.PushBack(tickData)

        if ind.periodCounter &gt; 0 </span><span class="cov7" title="1266">{

        }</span>
        <span class="cov7" title="1327">if ind.periodHistory.Len() &gt; ind.timePeriod </span><span class="cov7" title="1266">{
                var first = ind.periodHistory.Front()
                ind.periodHistory.Remove(first)
        }</span>

        <span class="cov7" title="1327">if ind.periodCounter &gt;= 0 </span><span class="cov7" title="1279">{

                // increment the number of results this indicator can be expected to return
                ind.dataLength += 1
                if ind.validFromBar == -1 </span><span class="cov3" title="13">{
                        // set the streamBarIndex from which this indicator returns valid results
                        ind.validFromBar = streamBarIndex
                }</span>

                // calculate the ind
                <span class="cov7" title="1279">var iter int = 1
                var sum float64 = 0
                for e := ind.periodHistory.Front(); e != nil; e = e.Next() </span><span class="cov8" title="7225">{
                        var localSum float64 = 0
                        for i := 1; i &lt;= iter; i++ </span><span class="cov10" title="31390">{
                                localSum += e.Value.(float64)
                        }</span>
                        <span class="cov8" title="7225">sum += localSum
                        iter++</span>
                }
                <span class="cov7" title="1279">var result float64 = sum / float64(ind.periodWeightTotal)

                // update the maximum result value
                if result &gt; ind.maxValue </span><span class="cov5" title="238">{
                        ind.maxValue = result
                }</span>

                // update the minimum result value
                <span class="cov7" title="1279">if result &lt; ind.minValue </span><span class="cov4" title="55">{
                        ind.minValue = result
                }</span>

                // notify of a new result value though the value available action
                <span class="cov7" title="1279">ind.valueAvailableAction(result, streamBarIndex)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
